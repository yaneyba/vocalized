---
tags:
  - vocalized
  - call-management
  - pipeline
---
## 5.1 Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                  Call Management Engine                     │
│                                                             │
│  ┌──────────────┐         ┌──────────────┐                  │ 
│  │   Twilio     │────────▶│   Webhook    │                  │
│  │   Telnyx     │         │   Handler    │                  │
│  └──────────────┘         └──────────────┘                  │
│                                  │                          │
│                                  ▼                          │
│                          ┌──────────────┐                   │
│                          │   Call       │                   │
│                          │   Router     │                   │
│                          └──────────────┘                   │
│                                  │                          │
│                   ┌──────────────┼──────────────┐           │
│                   ▼              ▼              ▼           │
│           ┌─────────────┐ ┌───────────┐ ┌─────────────┐     │ 
│           │   Agent     │ │   Call    │ │  Recording  │     │
│           │   Executor  │ │   State   │ │  Manager    │     │
│           └─────────────┘ │   (DO)    │ └─────────────┘     │
│                   │       └───────────┘        │            │
│                   ▼                            ▼            │
│           ┌─────────────┐              ┌─────────────┐      │
│           │   Voice AI  │              │     R2      │      │
│           │   Gateway   │              │  Storage    │      │
│           └─────────────┘              └─────────────┘      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 5.2 Core Types

```typescript
// ============================================
// CALL MANAGEMENT TYPES
// ============================================

interface CallState {
  callId: string;
  workspaceId: string;
  agentId: string;
  phoneNumberId: string;
  callerNumber: string;
  direction: 'inbound' | 'outbound';
  status: CallStatus;
  providerCallSid: string;
  voiceProvider: string;
  startedAt: number;
  endedAt?: number;
  conversationHistory: ConversationTurn[];
  metadata: Record<string, any>;
}

type CallStatus = 
  | 'queued'
  | 'ringing'
  | 'in-progress'
  | 'completed'
  | 'failed'
  | 'busy'
  | 'no-answer';

interface ConversationTurn {
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
  audioUrl?: string;
}

interface AgentConfig {
  id: string;
  workspaceId: string;
  name: string;
  config: {
    systemPrompt: string;
    callFlows: CallFlow[];
    voiceSettings: VoiceConfig;
    integrations: IntegrationAction[];
  };
  voiceProvider: string;
  voiceConfig: VoiceConfig;
}

interface CallFlow {
  id: string;
  name: string;
  trigger: FlowTrigger;
  steps: FlowStep[];
}

interface FlowTrigger {
  type: 'greeting' | 'intent' | 'keyword' | 'time';
  value?: string;
}

interface FlowStep {
  type: 'speak' | 'listen' | 'transfer' | 'hangup' | 'integration';
  content?: string;
  options?: any;
}

interface IntegrationAction {
  type: 'book_appointment' | 'lookup_customer' | 'create_ticket';
  integrationId: string;
  config: any;
}

// Twilio webhook payloads
interface TwilioInboundWebhook {
  CallSid: string;
  From: string;
  To: string;
  CallStatus: string;
  Direction: string;
  [key: string]: string;
}

interface TwilioStatusWebhook {
  CallSid: string;
  CallStatus: string;
  CallDuration?: string;
  RecordingUrl?: string;
  RecordingSid?: string;
  [key: string]: string;
}
```

---

## 5.3 Call State Durable Object

```typescript
// ============================================
// CALL STATE DURABLE OBJECT
// Maintains state for active calls
// ============================================

export class CallStateDO {
  private state: DurableObjectState;
  private env: Env;
  private callState: CallState | null = null;

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
  }

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    // Load state on first request
    if (!this.callState) {
      await this.loadState();
    }

    switch (path) {
      case '/init':
        return this.handleInit(request);
      
      case '/state':
        return this.handleGetState(request);
      
      case '/update':
        return this.handleUpdate(request);
      
      case '/add-turn':
        return this.handleAddTurn(request);
      
      case '/end':
        return this.handleEnd(request);
      
      default:
        return new Response('Not found', { status: 404 });
    }
  }

  private async loadState(): Promise<void> {
    this.callState = await this.state.storage.get<CallState>('call_state');
  }

  private async saveState(): Promise<void> {
    if (this.callState) {
      await this.state.storage.put('call_state', this.callState);
    }
  }

  private async handleInit(request: Request): Promise<Response> {
    const data = await request.json();

    this.callState = {
      callId: data.callId,
      workspaceId: data.workspaceId,
      agentId: data.agentId,
      phoneNumberId: data.phoneNumberId,
      callerNumber: data.callerNumber,
      direction: data.direction,
      status: 'ringing',
      providerCallSid: data.providerCallSid,
      voiceProvider: data.voiceProvider,
      startedAt: Date.now(),
      conversationHistory: [],
      metadata: data.metadata || {}
    };

    await this.saveState();

    return Response.json({ success: true });
  }

  private async handleGetState(request: Request): Promise<Response> {
    if (!this.callState) {
      return Response.json({ error: 'No state found' }, { status: 404 });
    }

    return Response.json(this.callState);
  }

  private async handleUpdate(request: Request): Promise<Response> {
    if (!this.callState) {
      return Response.json({ error: 'No state found' }, { status: 404 });
    }

    const updates = await request.json();

    // Update allowed fields
    if (updates.status) {
      this.callState.status = updates.status;
    }

    if (updates.metadata) {
      this.callState.metadata = {
        ...this.callState.metadata,
        ...updates.metadata
      };
    }

    await this.saveState();

    // Also persist to D1 for long-term storage
    await this.persistToDatabase();

    return Response.json({ success: true });
  }

  private async handleAddTurn(request: Request): Promise<Response> {
    if (!this.callState) {
      return Response.json({ error: 'No state found' }, { status: 404 });
    }

    const turn: ConversationTurn = await request.json();

    this.callState.conversationHistory.push(turn);

    await this.saveState();

    return Response.json({ success: true });
  }

  private async handleEnd(request: Request): Promise<Response> {
    if (!this.callState) {
      return Response.json({ error: 'No state found' }, { status: 404 });
    }

    const data = await request.json();

    this.callState.status = 'completed';
    this.callState.endedAt = Date.now();

    if (data.duration) {
      this.callState.metadata.duration = data.duration;
    }

    await this.saveState();

    // Persist final state to database
    await this.persistToDatabase();

    // Generate call summary
    await this.generateCallSummary();

    return Response.json({ success: true });
  }

  private async persistToDatabase(): Promise<void> {
    if (!this.callState) return;

    const duration = this.callState.endedAt
      ? Math.floor((this.callState.endedAt - this.callState.startedAt) / 1000)
      : null;

    try {
      await this.env.DB
        .prepare(`
          INSERT OR REPLACE INTO calls
          (id, workspace_id, agent_id, phone_number_id, caller_number, 
           direction, status, provider_call_sid, voice_provider_used, 
           duration_seconds, metadata, started_at, ended_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          this.callState.callId,
          this.callState.workspaceId,
          this.callState.agentId,
          this.callState.phoneNumberId,
          this.callState.callerNumber,
          this.callState.direction,
          this.callState.status,
          this.callState.providerCallSid,
          this.callState.voiceProvider,
          duration,
          JSON.stringify(this.callState.metadata),
          this.callState.startedAt,
          this.callState.endedAt || null
        )
        .run();
    } catch (error) {
      console.error('Failed to persist call to database:', error);
    }
  }

  private async generateCallSummary(): Promise<void> {
    if (!this.callState || this.callState.conversationHistory.length === 0) {
      return;
    }

    // Generate AI summary of conversation
    // This could use OpenAI or another LLM
    const conversation = this.callState.conversationHistory
      .map(turn => `${turn.role}: ${turn.content}`)
      .join('\n');

    // For now, just store the conversation
    // In production, call an LLM API to generate summary
    const summary = `Call with ${this.callState.conversationHistory.length} exchanges`;

    try {
      await this.env.DB
        .prepare(`
          UPDATE calls 
          SET summary = ?, transcription = ?
          WHERE id = ?
        `)
        .bind(
          summary,
          conversation,
          this.callState.callId
        )
        .run();
    } catch (error) {
      console.error('Failed to save call summary:', error);
    }
  }
}
```

---

## 5.4 Call Router

```typescript
// ============================================
// CALL ROUTER
// Routes incoming calls to appropriate agents
// ============================================

class CallRouter {
  constructor(private env: Env) {}

  async routeInboundCall(
    phoneNumber: string,
    callerNumber: string,
    providerCallSid: string
  ): Promise<{
    agent: AgentConfig;
    workspaceId: string;
    phoneNumberId: string;
  }> {
    
    // 1. Find phone number record
    const phoneRecord = await this.env.DB
      .prepare(`
        SELECT id, workspace_id 
        FROM phone_numbers 
        WHERE phone_number = ? AND status = 'active'
      `)
      .bind(phoneNumber)
      .first();

    if (!phoneRecord) {
      throw new Error(`Phone number not found: ${phoneNumber}`);
    }

    // 2. Find active agent for this phone number
    const agentRecord = await this.env.DB
      .prepare(`
        SELECT id, config, voice_provider, voice_config
        FROM voice_agents
        WHERE phone_number_id = ? AND status = 'live'
      `)
      .bind(phoneRecord.id)
      .first();

    if (!agentRecord) {
      throw new Error(`No active agent for phone number: ${phoneNumber}`);
    }

    // 3. Parse agent configuration
    const agent: AgentConfig = {
      id: agentRecord.id,
      workspaceId: phoneRecord.workspace_id,
      name: agentRecord.name || 'Agent',
      config: JSON.parse(agentRecord.config),
      voiceProvider: agentRecord.voice_provider,
      voiceConfig: JSON.parse(agentRecord.voice_config)
    };

    return {
      agent,
      workspaceId: phoneRecord.workspace_id,
      phoneNumberId: phoneRecord.id
    };
  }

  async routeOutboundCall(
    workspaceId: string,
    agentId: string,
    toNumber: string
  ): Promise<{
    agent: AgentConfig;
    phoneNumberId: string;
  }> {
    
    // Get agent config
    const agentRecord = await this.env.DB
      .prepare(`
        SELECT id, phone_number_id, config, voice_provider, voice_config
        FROM voice_agents
        WHERE id = ? AND workspace_id = ? AND status = 'live'
      `)
      .bind(agentId, workspaceId)
      .first();

    if (!agentRecord) {
      throw new Error(`Agent not found or not active: ${agentId}`);
    }

    const agent: AgentConfig = {
      id: agentRecord.id,
      workspaceId,
      name: agentRecord.name || 'Agent',
      config: JSON.parse(agentRecord.config),
      voiceProvider: agentRecord.voice_provider,
      voiceConfig: JSON.parse(agentRecord.voice_config)
    };

    return {
      agent,
      phoneNumberId: agentRecord.phone_number_id
    };
  }
}
```

---

## 5.5 Agent Executor

```typescript
// ============================================
// AGENT EXECUTOR
// Executes agent logic during calls
// ============================================

class AgentExecutor {
  constructor(
    private env: Env,
    private gateway: VoiceGateway
  ) {}

  async handleCallStart(
    callState: CallState,
    agent: AgentConfig
  ): Promise<string> {
    
    // Find greeting flow
    const greetingFlow = agent.config.callFlows.find(
      f => f.trigger.type === 'greeting'
    );

    if (!greetingFlow) {
      return "Hello, how can I help you today?";
    }

    // Execute first step (usually a speak step)
    const firstStep = greetingFlow.steps[0];
    
    if (firstStep.type === 'speak') {
      return firstStep.content || "Hello, how can I help you today?";
    }

    return "Hello, how can I help you today?";
  }

  async handleUserInput(
    callState: CallState,
    agent: AgentConfig,
    userInput: string
  ): Promise<string> {
    
    // Add user turn to conversation history
    await this.addConversationTurn(callState.callId, {
      role: 'user',
      content: userInput,
      timestamp: Date.now()
    });

    // Detect intent
    const intent = await this.detectIntent(userInput, agent);

    // Find matching flow
    const matchingFlow = agent.config.callFlows.find(
      f => f.trigger.type === 'intent' && f.trigger.value === intent
    );

    if (matchingFlow) {
      return await this.executeFlow(matchingFlow, callState, agent, userInput);
    }

    // Fallback to general conversation
    return await this.generateResponse(
      agent.config.systemPrompt,
      callState.conversationHistory,
      userInput
    );
  }

  private async detectIntent(
    input: string,
    agent: AgentConfig
  ): Promise<string> {
    
    // Simple keyword matching (could use NLP/LLM)
    const lowerInput = input.toLowerCase();

    if (lowerInput.includes('appointment') || lowerInput.includes('book')) {
      return 'book_appointment';
    }

    if (lowerInput.includes('cancel')) {
      return 'cancel_appointment';
    }

    if (lowerInput.includes('hours') || lowerInput.includes('open')) {
      return 'business_hours';
    }

    if (lowerInput.includes('price') || lowerInput.includes('cost')) {
      return 'pricing';
    }

    return 'general';
  }

  private async executeFlow(
    flow: CallFlow,
    callState: CallState,
    agent: AgentConfig,
    userInput: string
  ): Promise<string> {
    
    let response = '';

    for (const step of flow.steps) {
      switch (step.type) {
        case 'speak':
          response += step.content + ' ';
          break;

        case 'integration':
          const integrationResult = await this.executeIntegration(
            step,
            callState,
            agent,
            userInput
          );
          response += integrationResult + ' ';
          break;

        case 'transfer':
          // Handle call transfer
          response += 'Transferring you now...';
          break;

        case 'hangup':
          response += 'Thank you for calling. Goodbye!';
          break;
      }
    }

    return response.trim();
  }

  private async executeIntegration(
    step: FlowStep,
    callState: CallState,
    agent: AgentConfig,
    userInput: string
  ): Promise<string> {
    
    // Find integration config
    const integration = agent.config.integrations.find(
      i => i.type === step.options?.action
    );

    if (!integration) {
      return "I'm sorry, I'm having trouble with that right now.";
    }

    // Get integration credentials
    const integrationRecord = await this.env.DB
      .prepare(`
        SELECT id, integration_type, credentials_encrypted, config
        FROM workspace_integrations
        WHERE id = ? AND workspace_id = ?
      `)
      .bind(integration.integrationId, callState.workspaceId)
      .first();

    if (!integrationRecord || integrationRecord.status !== 'connected') {
      return "I'm sorry, that integration is not available right now.";
    }

    // Execute integration action
    switch (integration.type) {
      case 'book_appointment':
        return await this.bookAppointment(
          integrationRecord,
          callState,
          userInput
        );

      case 'lookup_customer':
        return await this.lookupCustomer(
          integrationRecord,
          callState.callerNumber
        );

      default:
        return "Action completed.";
    }
  }

  private async bookAppointment(
    integration: any,
    callState: CallState,
    userInput: string
  ): Promise<string> {
    
    // Parse appointment details from user input
    // This would use NLP/LLM to extract date, time, service, etc.
    
    // For now, simplified example
    return "I've booked an appointment for you. You'll receive a confirmation shortly.";
  }

  private async lookupCustomer(
    integration: any,
    phoneNumber: string
  ): Promise<string> {
    
    // Look up customer in CRM by phone number
    // This would call the actual CRM API
    
    return "I found your information in our system.";
  }

  private async generateResponse(
    systemPrompt: string,
    conversationHistory: ConversationTurn[],
    userInput: string
  ): Promise<string> {
    
    // This would call an LLM API (OpenAI, Anthropic, etc.)
    // For now, return a simple response
    
    return "I understand. How else can I help you?";
  }

  private async addConversationTurn(
    callId: string,
    turn: ConversationTurn
  ): Promise<void> {
    
    const doId = this.env.CALL_STATE_DO.idFromName(callId);
    const doStub = this.env.CALL_STATE_DO.get(doId);
    
    await doStub.fetch('https://do/add-turn', {
      method: 'POST',
      body: JSON.stringify(turn)
    });
  }
}
```

---

## 5.6 Webhook Handler

```typescript
// ============================================
// WEBHOOK HANDLER
// Handles webhooks from Twilio/Telnyx
// ============================================

class WebhookHandler {
  constructor(
    private env: Env,
    private router: CallRouter,
    private executor: AgentExecutor
  ) {}

  async handleInboundCall(
    webhook: TwilioInboundWebhook
  ): Promise<Response> {
    
    try {
      // Route the call
      const { agent, workspaceId, phoneNumberId } = 
        await this.router.routeInboundCall(
          webhook.To,
          webhook.From,
          webhook.CallSid
        );

      // Create call record
      const callId = crypto.randomUUID();

      // Initialize call state in Durable Object
      const doId = this.env.CALL_STATE_DO.idFromName(callId);
      const doStub = this.env.CALL_STATE_DO.get(doId);

      await doStub.fetch('https://do/init', {
        method: 'POST',
        body: JSON.stringify({
          callId,
          workspaceId,
          agentId: agent.id,
          phoneNumberId,
          callerNumber: webhook.From,
          direction: 'inbound',
          providerCallSid: webhook.CallSid,
          voiceProvider: agent.voiceProvider
        })
      });

      // Generate greeting
      const greeting = await this.executor.handleCallStart(
        { callId, workspaceId, agentId: agent.id } as any,
        agent
      );

      // Synthesize greeting audio
      const gateway = new VoiceGateway(this.env);
      const audioResponse = await gateway.synthesize({
        workspaceId,
        operation: 'synthesize',
        text: greeting,
        voiceConfig: agent.voiceConfig
      });

      // Return TwiML response
      const twiml = this.generateTwiML(greeting, callId, audioResponse);

      return new Response(twiml, {
        headers: { 'Content-Type': 'text/xml' }
      });

    } catch (error) {
      console.error('Inbound call handling failed:', error);

      // Return error TwiML
      const errorTwiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say>We're sorry, but we're unable to take your call right now. Please try again later.</Say>
  <Hangup/>
</Response>`;

      return new Response(errorTwiml, {
        headers: { 'Content-Type': 'text/xml' }
      });
    }
  }

  async handleStatusUpdate(
    webhook: TwilioStatusWebhook
  ): Promise<Response> {
    
    try {
      // Find call by provider SID
      const callRecord = await this.env.DB
        .prepare(`
          SELECT id FROM calls 
          WHERE provider_call_sid = ?
        `)
        .bind(webhook.CallSid)
        .first();

      if (!callRecord) {
        return Response.json({ success: true }); // Call not found, ignore
      }

      // Update call state
      const doId = this.env.CALL_STATE_DO.idFromName(callRecord.id);
      const doStub = this.env.CALL_STATE_DO.get(doId);

      await doStub.fetch('https://do/update', {
        method: 'POST',
        body: JSON.stringify({
          status: this.mapTwilioStatus(webhook.CallStatus),
          metadata: {
            twilioStatus: webhook.CallStatus
          }
        })
      });

      // If call ended, finalize
      if (webhook.CallStatus === 'completed') {
        await doStub.fetch('https://do/end', {
          method: 'POST',
          body: JSON.stringify({
            duration: webhook.CallDuration
          })
        });
      }

      return Response.json({ success: true });

    } catch (error) {
      console.error('Status update handling failed:', error);
      return Response.json({ error: error.message }, { status: 500 });
    }
  }

  async handleRecording(
    webhook: TwilioStatusWebhook
  ): Promise<Response> {
    
    try {
      if (!webhook.RecordingUrl || !webhook.RecordingSid) {
        return Response.json({ success: true });
      }

      // Find call
      const callRecord = await this.env.DB
        .prepare(`
          SELECT id, workspace_id FROM calls 
          WHERE provider_call_sid = ?
        `)
        .bind(webhook.CallSid)
        .first();

      if (!callRecord) {
        return Response.json({ success: true });
      }

      // Download recording from Twilio
      const recordingData = await this.downloadRecording(webhook.RecordingUrl);

      // Upload to R2
      const r2Key = `recordings/${callRecord.workspace_id}/${callRecord.id}.mp3`;
      await this.env.R2_RECORDINGS.put(r2Key, recordingData);

      // Update database with R2 URL
      const r2Url = `https://recordings.vocalized.app/${r2Key}`;
      
      await this.env.DB
        .prepare(`
          UPDATE calls 
          SET recording_url = ?
          WHERE id = ?
        `)
        .bind(r2Url, callRecord.id)
        .run();

      // Trigger transcription
      await this.transcribeRecording(callRecord.id, recordingData);

      return Response.json({ success: true });

    } catch (error) {
      console.error('Recording handling failed:', error);
      return Response.json({ error: error.message }, { status: 500 });
    }
  }

  private async downloadRecording(url: string): Promise<ArrayBuffer> {
    // Add Twilio auth
    const twilioAuth = btoa(
      `${this.env.TWILIO_ACCOUNT_SID}:${this.env.TWILIO_AUTH_TOKEN}`
    );

    const response = await fetch(url, {
      headers: {
        'Authorization': `Basic ${twilioAuth}`
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to download recording: ${response.status}`);
    }

    return await response.arrayBuffer();
  }

  private async transcribeRecording(
    callId: string,
    audio: ArrayBuffer
  ): Promise<void> {
    
    // Get call details
    const call = await this.env.DB
      .prepare(`SELECT workspace_id FROM calls WHERE id = ?`)
      .bind(callId)
      .first();

    if (!call) return;

    // Transcribe using Voice Gateway
    const gateway = new VoiceGateway(this.env);
    
    try {
      const transcription = await gateway.transcribe({
        workspaceId: call.workspace_id,
        operation: 'transcribe',
        audio,
        transcribeConfig: {
          punctuate: true,
          diarize: true
        }
      });

      // Save transcription
      await this.env.DB
        .prepare(`
          UPDATE calls 
          SET transcription = ?
          WHERE id = ?
        `)
        .bind(transcription.text, callId)
        .run();

    } catch (error) {
      console.error('Transcription failed:', error);
    }
  }

  private mapTwilioStatus(twilioStatus: string): CallStatus {
    const statusMap: Record<string, CallStatus> = {
      'queued': 'queued',
      'ringing': 'ringing',
      'in-progress': 'in-progress',
      'completed': 'completed',
      'busy': 'busy',
      'failed': 'failed',
      'no-answer': 'no-answer'
    };

    return statusMap[twilioStatus] || 'failed';
  }

  private generateTwiML(
    text: string,
    callId: string,
    audioResponse: any
  ): string {
    
    // For simplicity, using <Say> instead of streaming audio
    // In production, you'd stream the audio from Voice Gateway
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">${this.escapeXml(text)}</Say>
  <Gather input="speech" action="/webhooks/calls/gather?callId=${callId}" method="POST" timeout="5" speechTimeout="auto">
    <Say>Please tell me how I can help you.</Say>
  </Gather>
  <Say>I didn't hear anything. Goodbye!</Say>
  <Hangup/>
</Response>`;
  }

  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
}
```

---

**Continue with Part 2 of Call Management Engine (Outbound calls, Call worker entry point)?**
#vocalized