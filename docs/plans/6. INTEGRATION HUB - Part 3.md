---
tags:
  - pipeline
  - vocalized
  - integration-hub
---
## 6.8 Webhook Handler

```typescript
// ============================================
// WEBHOOK HANDLER
// Handles incoming webhooks from integrations
// ============================================

class IntegrationWebhookHandler {
  constructor(private env: Env) {}

  async handleWebhook(
    integrationType: IntegrationType,
    request: Request
  ): Promise<Response> {
    
    switch (integrationType) {
      case 'salesforce':
        return this.handleSalesforceWebhook(request);
      
      case 'hubspot':
        return this.handleHubSpotWebhook(request);
      
      case 'square':
        return this.handleSquareWebhook(request);
      
      case 'fresha':
        return this.handleFreshaWebhook(request);
      
      default:
        return Response.json(
          { error: 'Unsupported webhook type' },
          { status: 400 }
        );
    }
  }

  private async handleSalesforceWebhook(request: Request): Promise<Response> {
    try {
      const payload = await request.json();

      // Salesforce sends notifications for object changes
      // Process based on object type
      const objectType = payload.sobject?.attributes?.type;

      switch (objectType) {
        case 'Contact':
          await this.processSalesforceContact(payload);
          break;
        
        case 'Opportunity':
          await this.processSalesforceOpportunity(payload);
          break;
      }

      return Response.json({ success: true });

    } catch (error) {
      console.error('Salesforce webhook error:', error);
      return Response.json({ error: error.message }, { status: 500 });
    }
  }

  private async handleHubSpotWebhook(request: Request): Promise<Response> {
    try {
      const payload = await request.json();

      // HubSpot sends arrays of events
      for (const event of payload) {
        const objectType = event.objectType; // contact, deal, company
        const eventType = event.changeFlag; // CREATED, UPDATED, DELETED

        switch (objectType) {
          case 'CONTACT':
            await this.processHubSpotContact(event, eventType);
            break;
          
          case 'DEAL':
            await this.processHubSpotDeal(event, eventType);
            break;
        }
      }

      return Response.json({ success: true });

    } catch (error) {
      console.error('HubSpot webhook error:', error);
      return Response.json({ error: error.message }, { status: 500 });
    }
  }

  private async handleSquareWebhook(request: Request): Promise<Response> {
    try {
      // Verify Square signature
      const signature = request.headers.get('x-square-hmacsha256-signature');
      const body = await request.text();

      if (!this.verifySquareSignature(signature, body)) {
        return Response.json({ error: 'Invalid signature' }, { status: 401 });
      }

      const payload = JSON.parse(body);

      // Process based on event type
      switch (payload.type) {
        case 'booking.created':
        case 'booking.updated':
          await this.processSquareBooking(payload.data.object);
          break;
        
        case 'customer.created':
        case 'customer.updated':
          await this.processSquareCustomer(payload.data.object);
          break;
      }

      return Response.json({ success: true });

    } catch (error) {
      console.error('Square webhook error:', error);
      return Response.json({ error: error.message }, { status: 500 });
    }
  }

  private async handleFreshaWebhook(request: Request): Promise<Response> {
    try {
      const payload = await request.json();

      // Fresha webhook format
      const eventType = payload.event_type;
      const data = payload.data;

      switch (eventType) {
        case 'appointment.created':
        case 'appointment.updated':
        case 'appointment.cancelled':
          await this.processFreshaAppointment(data, eventType);
          break;
        
        case 'client.created':
        case 'client.updated':
          await this.processFreshaClient(data, eventType);
          break;
      }

      return Response.json({ success: true });

    } catch (error) {
      console.error('Fresha webhook error:', error);
      return Response.json({ error: error.message }, { status: 500 });
    }
  }

  // Webhook processors
  private async processSalesforceContact(payload: any): Promise<void> {
    // Find integration that handles this Salesforce account
    const integration = await this.findIntegrationByExternalId(
      'salesforce',
      payload.organizationId
    );

    if (!integration) return;

    // Store/update contact in workspace
    await this.storeExternalContact(integration.workspace_id, {
      integrationId: integration.id,
      externalId: payload.sobject.Id,
      name: payload.sobject.Name,
      email: payload.sobject.Email,
      phone: payload.sobject.Phone,
      rawData: payload.sobject
    });
  }

  private async processHubSpotContact(event: any, eventType: string): Promise<void> {
    // Find integration by portal ID
    const integration = await this.findIntegrationByExternalId(
      'hubspot',
      event.portalId.toString()
    );

    if (!integration) return;

    if (eventType === 'DELETED') {
      await this.deleteExternalContact(integration.workspace_id, event.objectId);
    } else {
      // Fetch full contact details from HubSpot
      // Store/update in workspace
      await this.storeExternalContact(integration.workspace_id, {
        integrationId: integration.id,
        externalId: event.objectId.toString(),
        name: event.properties?.firstname + ' ' + event.properties?.lastname,
        email: event.properties?.email,
        phone: event.properties?.phone,
        rawData: event.properties
      });
    }
  }

  private async processSquareBooking(booking: any): Promise<void> {
    // Find integration by merchant ID
    const integration = await this.findIntegrationByExternalId(
      'square',
      booking.merchant_id
    );

    if (!integration) return;

    // Store appointment
    await this.storeExternalAppointment(integration.workspace_id, {
      integrationId: integration.id,
      externalId: booking.id,
      customerId: booking.customer_id,
      startTime: booking.start_at,
      endTime: booking.end_at,
      status: booking.status,
      rawData: booking
    });
  }

  private async processFreshaAppointment(
    appointment: any,
    eventType: string
  ): Promise<void> {
    
    // Find integration by business ID
    const integration = await this.findIntegrationByExternalId(
      'fresha',
      appointment.business_id
    );

    if (!integration) return;

    if (eventType === 'appointment.cancelled') {
      await this.deleteExternalAppointment(integration.workspace_id, appointment.id);
    } else {
      await this.storeExternalAppointment(integration.workspace_id, {
        integrationId: integration.id,
        externalId: appointment.id,
        customerId: appointment.client_id,
        startTime: appointment.start_time,
        endTime: appointment.end_time,
        status: appointment.status,
        rawData: appointment
      });
    }
  }

  private async processSquareCustomer(customer: any): Promise<void> {
    const integration = await this.findIntegrationByExternalId(
      'square',
      customer.merchant_id
    );

    if (!integration) return;

    await this.storeExternalContact(integration.workspace_id, {
      integrationId: integration.id,
      externalId: customer.id,
      name: `${customer.given_name} ${customer.family_name}`,
      email: customer.email_address,
      phone: customer.phone_number,
      rawData: customer
    });
  }

  private async processFreshaClient(client: any, eventType: string): Promise<void> {
    const integration = await this.findIntegrationByExternalId(
      'fresha',
      client.business_id
    );

    if (!integration) return;

    if (eventType === 'client.deleted') {
      await this.deleteExternalContact(integration.workspace_id, client.id);
    } else {
      await this.storeExternalContact(integration.workspace_id, {
        integrationId: integration.id,
        externalId: client.id,
        name: `${client.first_name} ${client.last_name}`,
        email: client.email,
        phone: client.phone,
        rawData: client
      });
    }
  }

  // Helper methods
  private async findIntegrationByExternalId(
    type: string,
    externalId: string
  ): Promise<any> {
    
    return await this.env.DB
      .prepare(`
        SELECT id, workspace_id
        FROM workspace_integrations
        WHERE integration_type = ? 
        AND json_extract(config, '$.externalId') = ?
      `)
      .bind(type, externalId)
      .first();
  }

  private async storeExternalContact(
    workspaceId: string,
    contact: {
      integrationId: string;
      externalId: string;
      name: string;
      email?: string;
      phone?: string;
      rawData: any;
    }
  ): Promise<void> {
    
    // Store in a synced_contacts table
    await this.env.DB
      .prepare(`
        INSERT OR REPLACE INTO synced_contacts
        (id, workspace_id, integration_id, external_id, name, email, phone, raw_data, synced_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        crypto.randomUUID(),
        workspaceId,
        contact.integrationId,
        contact.externalId,
        contact.name,
        contact.email || null,
        contact.phone || null,
        JSON.stringify(contact.rawData),
        Date.now()
      )
      .run();
  }

  private async deleteExternalContact(
    workspaceId: string,
    externalId: string
  ): Promise<void> {
    
    await this.env.DB
      .prepare(`
        DELETE FROM synced_contacts
        WHERE workspace_id = ? AND external_id = ?
      `)
      .bind(workspaceId, externalId)
      .run();
  }

  private async storeExternalAppointment(
    workspaceId: string,
    appointment: {
      integrationId: string;
      externalId: string;
      customerId?: string;
      startTime: string;
      endTime: string;
      status: string;
      rawData: any;
    }
  ): Promise<void> {
    
    await this.env.DB
      .prepare(`
        INSERT OR REPLACE INTO synced_appointments
        (id, workspace_id, integration_id, external_id, customer_id, start_time, end_time, status, raw_data, synced_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        crypto.randomUUID(),
        workspaceId,
        appointment.integrationId,
        appointment.externalId,
        appointment.customerId || null,
        appointment.startTime,
        appointment.endTime,
        appointment.status,
        JSON.stringify(appointment.rawData),
        Date.now()
      )
      .run();
  }

  private async deleteExternalAppointment(
    workspaceId: string,
    externalId: string
  ): Promise<void> {
    
    await this.env.DB
      .prepare(`
        DELETE FROM synced_appointments
        WHERE workspace_id = ? AND external_id = ?
      `)
      .bind(workspaceId, externalId)
      .run();
  }

  private verifySquareSignature(signature: string | null, body: string): boolean {
    if (!signature) return false;

    // Implement HMAC verification
    // const hmac = crypto.createHmac('sha256', this.env.SQUARE_WEBHOOK_SIGNATURE_KEY);
    // hmac.update(body);
    // const computed = hmac.digest('base64');
    
    // For now, simplified version
    return true; // In production, implement proper verification
  }
}

// Add these tables to schema
/*
CREATE TABLE synced_contacts (
    id TEXT PRIMARY KEY,
    workspace_id TEXT NOT NULL,
    integration_id TEXT NOT NULL,
    external_id TEXT NOT NULL,
    name TEXT NOT NULL,
    email TEXT,
    phone TEXT,
    raw_data TEXT, -- JSON
    synced_at INTEGER NOT NULL,
    FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE,
    FOREIGN KEY (integration_id) REFERENCES workspace_integrations(id) ON DELETE CASCADE,
    UNIQUE(integration_id, external_id)
);

CREATE INDEX idx_synced_contacts_workspace ON synced_contacts(workspace_id);
CREATE INDEX idx_synced_contacts_integration ON synced_contacts(integration_id);
CREATE INDEX idx_synced_contacts_phone ON synced_contacts(phone);
CREATE INDEX idx_synced_contacts_email ON synced_contacts(email);

CREATE TABLE synced_appointments (
    id TEXT PRIMARY KEY,
    workspace_id TEXT NOT NULL,
    integration_id TEXT NOT NULL,
    external_id TEXT NOT NULL,
    customer_id TEXT,
    start_time TEXT NOT NULL,
    end_time TEXT NOT NULL,
    status TEXT NOT NULL,
    raw_data TEXT, -- JSON
    synced_at INTEGER NOT NULL,
    FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE,
    FOREIGN KEY (integration_id) REFERENCES workspace_integrations(id) ON DELETE CASCADE,
    UNIQUE(integration_id, external_id)
);

CREATE INDEX idx_synced_appointments_workspace ON synced_appointments(workspace_id);
CREATE INDEX idx_synced_appointments_integration ON synced_appointments(integration_id);
CREATE INDEX idx_synced_appointments_start ON synced_appointments(start_time);
*/
```

---

## 6.9 Integration Actions (for AI Agents)

```typescript
// ============================================
// INTEGRATION ACTIONS
// Used by AI agents during calls
// ============================================

class IntegrationActions {
  constructor(private env: Env) {}

  async executeAction(
    workspaceId: string,
    integrationId: string,
    action: string,
    params: any
  ): Promise<any> {
    
    // Get integration
    const integration = await this.env.DB
      .prepare(`
        SELECT integration_type, credentials_encrypted, config
        FROM workspace_integrations
        WHERE id = ? AND workspace_id = ? AND status = 'connected'
      `)
      .bind(integrationId, workspaceId)
      .first();

    if (!integration) {
      throw new Error('Integration not found or not connected');
    }

    // Decrypt credentials
    const oauthManager = new OAuthManager(this.env);
    const tokens = await oauthManager['decryptTokens'](integration.credentials_encrypted);

    const credentials: IntegrationCredentials = {
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken
    };

    // Get connector
    const connector = ConnectorFactory.create(
      integration.integration_type as IntegrationType,
      this.env
    );

    // Execute action
    switch (action) {
      case 'book_appointment':
        return await this.bookAppointment(connector, credentials, params);
      
      case 'check_availability':
        return await this.checkAvailability(connector, credentials, params);
      
      case 'lookup_contact':
        return await this.lookupContact(connector, credentials, params);
      
      case 'create_contact':
        return await this.createContact(connector, credentials, params);
      
      default:
        throw new Error(`Unknown action: ${action}`);
    }
  }

  private async bookAppointment(
    connector: IntegrationConnector,
    credentials: IntegrationCredentials,
    params: {
      customerId?: string;
      customerPhone?: string;
      serviceId?: string;
      staffId?: string;
      startTime: string;
      endTime: string;
      notes?: string;
    }
  ): Promise<any> {
    
    // If no customerId provided, try to find by phone
    let customerId = params.customerId;

    if (!customerId && params.customerPhone && connector.lookupContact) {
      const contact = await connector.lookupContact(credentials, params.customerPhone);
      customerId = contact?.id;

      // Create contact if not found
      if (!customerId && connector.createContact) {
        const newContact = await connector.createContact(credentials, {
          name: 'Customer',
          phone: params.customerPhone
        });
        customerId = newContact.id;
      }
    }

    // Book appointment
    if (!connector.createAppointment) {
      throw new Error('This integration does not support appointment booking');
    }

    const appointment = await connector.createAppointment(credentials, {
      customerId,
      serviceId: params.serviceId,
      staffId: params.staffId,
      startTime: params.startTime,
      endTime: params.endTime,
      notes: params.notes
    });

    return {
      success: true,
      appointmentId: appointment.id,
      details: appointment
    };
  }

  private async checkAvailability(
    connector: IntegrationConnector,
    credentials: IntegrationCredentials,
    params: {
      start: string;
      end: string;
      serviceId?: string;
    }
  ): Promise<any> {
    
    if (!connector.getAvailability) {
      throw new Error('This integration does not support availability checking');
    }

    const availability = await connector.getAvailability(credentials, params);

    return {
      success: true,
      availability
    };
  }

  private async lookupContact(
    connector: IntegrationConnector,
    credentials: IntegrationCredentials,
    params: {
      identifier: string; // phone or email
    }
  ): Promise<any> {
    
    if (!connector.lookupContact) {
      throw new Error('This integration does not support contact lookup');
    }

    const contact = await connector.lookupContact(credentials, params.identifier);

    if (!contact) {
      return {
        success: false,
        found: false
      };
    }

    return {
      success: true,
      found: true,
      contact
    };
  }

  private async createContact(
    connector: IntegrationConnector,
    credentials: IntegrationCredentials,
    params: ContactData
  ): Promise<any> {
    
    if (!connector.createContact) {
      throw new Error('This integration does not support contact creation');
    }

    const contact = await connector.createContact(credentials, params);

    return {
      success: true,
      contactId: contact.id,
      contact
    };
  }

  // Helper method for AI agents to get synced data
  async getSyncedContact(
    workspaceId: string,
    phoneOrEmail: string
  ): Promise<any> {
    
    const contact = await this.env.DB
      .prepare(`
        SELECT * FROM synced_contacts
        WHERE workspace_id = ? AND (phone = ? OR email = ?)
        ORDER BY synced_at DESC
        LIMIT 1
      `)
      .bind(workspaceId, phoneOrEmail, phoneOrEmail)
      .first();

    if (!contact) return null;

    return {
      id: contact.id,
      name: contact.name,
      email: contact.email,
      phone: contact.phone,
      integrationId: contact.integration_id,
      rawData: JSON.parse(contact.raw_data)
    };
  }

  async getSyncedAppointments(
    workspaceId: string,
    startDate: string,
    endDate: string
  ): Promise<any[]> {
    
    const appointments = await this.env.DB
      .prepare(`
        SELECT * FROM synced_appointments
        WHERE workspace_id = ? 
        AND start_time >= ? 
        AND start_time <= ?
        ORDER BY start_time ASC
      `)
      .bind(workspaceId, startDate, endDate)
      .all();

    return appointments.results.map(apt => ({
      id: apt.id,
      externalId: apt.external_id,
      customerId: apt.customer_id,
      startTime: apt.start_time,
      endTime: apt.end_time,
      status: apt.status,
      integrationId: apt.integration_id,
      rawData: JSON.parse(apt.raw_data)
    }));
  }
}
```

---

## 6.10 Integration Hub Worker Entry Point

```typescript
// ============================================
// INTEGRATION HUB WORKER
// Main entry point
// ============================================

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      const oauthManager = new OAuthManager(env);
      const syncEngine = new SyncEngine(env);
      const webhookHandler = new IntegrationWebhookHandler(env);
      const actions = new IntegrationActions(env);

      // OAuth flow initiation
      if (path.match(/^\/workspaces\/[^/]+\/integrations$/) && request.method === 'POST') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/integrations$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);

        const body = await request.json();
        const { authUrl, state } = await oauthManager.initiateFlow(
          workspaceId,
          body.integrationType
        );

        return Response.json({ authUrl, state }, { headers: corsHeaders });
      }

      // OAuth callback
      if (path.match(/^\/integrations\/oauth\/callback\/[^/]+$/) && request.method === 'GET') {
        const match = path.match(/^\/integrations\/oauth\/callback\/([^/]+)$/);
        const integrationType = match![1] as IntegrationType;

        const code = url.searchParams.get('code');
        const state = url.searchParams.get('state');

        if (!code || !state) {
          return new Response('Missing code or state', { status: 400 });
        }

        const { workspaceId, integrationId } = await oauthManager.handleCallback(
          integrationType,
          code,
          state
        );

        // Redirect to client app
        const redirectUrl = `https://app.vocalized.app/workspaces/${workspaceId}/integrations?success=true&integrationId=${integrationId}`;
        
        return Response.redirect(redirectUrl, 302);
      }

      // Get integrations
      if (path.match(/^\/workspaces\/[^/]+\/integrations$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/integrations$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const integrations = await env.DB
          .prepare(`
            SELECT id, integration_type, name, status, last_sync_at, created_at
            FROM workspace_integrations
            WHERE workspace_id = ?
            ORDER BY created_at DESC
          `)
          .bind(workspaceId)
          .all();

        return Response.json(
          { integrations: integrations.results },
          { headers: corsHeaders }
        );
      }

      // Get integration details
      if (path.match(/^\/workspaces\/[^/]+\/integrations\/[^/]+$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/integrations\/([^/]+)$/);
        const workspaceId = match![1];
        const integrationId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId);

        const integration = await env.DB
          .prepare(`
            SELECT id, integration_type, name, status, config, last_sync_at, last_sync_status, created_at, updated_at
            FROM workspace_integrations
            WHERE id = ? AND workspace_id = ?
          `)
          .bind(integrationId, workspaceId)
          .first();

        if (!integration) {
          return Response.json(
            { error: 'Integration not found' },
            { status: 404, headers: corsHeaders }
          );
        }

        // Get recent sync logs
        const syncLogs = await env.DB
          .prepare(`
            SELECT id, sync_type, status, records_synced, started_at, completed_at
            FROM integration_sync_logs
            WHERE integration_id = ?
            ORDER BY started_at DESC
            LIMIT 10
          `)
          .bind(integrationId)
          .all();

        return Response.json(
          {
            integration,
            syncLogs: syncLogs.results
          },
          { headers: corsHeaders }
        );
      }

      // Trigger manual sync
      if (path.match(/^\/workspaces\/[^/]+\/integrations\/[^/]+\/sync$/) && request.method === 'POST') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/integrations\/([^/]+)\/sync$/);
        const workspaceId = match![1];
        const integrationId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);

        // Queue sync job
        await env.SYNC_QUEUE.send({
          integrationId,
          syncType: 'full'
        });

        return Response.json(
          { success: true, message: 'Sync initiated' },
          { headers: corsHeaders }
        );
      }

      // Delete integration
      if (path.match(/^\/workspaces\/[^/]+\/integrations\/[^/]+$/) && request.method === 'DELETE') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/integrations\/([^/]+)$/);
        const workspaceId = match![1];
        const integrationId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);

        await env.DB
          .prepare(`DELETE FROM workspace_integrations WHERE id = ? AND workspace_id = ?`)
          .bind(integrationId, workspaceId)
          .run();

        return Response.json({ success: true }, { headers: corsHeaders });
      }

      // Execute integration action (for AI agents)
      if (path.match(/^\/workspaces\/[^/]+\/integrations\/[^/]+\/actions$/) && request.method === 'POST') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/integrations\/([^/]+)\/actions$/);
        const workspaceId = match![1];
        const integrationId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId);

        const body = await request.json();
        const result = await actions.executeAction(
          workspaceId,
          integrationId,
          body.action,
          body.params
        );

        return Response.json(result, { headers: corsHeaders });
      }

      // Get synced contacts
      if (path.match(/^\/workspaces\/[^/]+\/contacts\/lookup$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/contacts\/lookup$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const identifier = url.searchParams.get('identifier');
        if (!identifier) {
          return Response.json(
            { error: 'Missing identifier parameter' },
            { status: 400, headers: corsHeaders }
          );
        }

        const contact = await actions.getSyncedContact(workspaceId, identifier);

        return Response.json(
          { contact: contact || null },
          { headers: corsHeaders }
        );
      }

      // Get synced appointments
      if (path.match(/^\/workspaces\/[^/]+\/appointments$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/appointments$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const startDate = url.searchParams.get('start') || new Date().toISOString();
        const endDate = url.searchParams.get('end') || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString();

        const appointments = await actions.getSyncedAppointments(
          workspaceId,
          startDate,
          endDate
        );

        return Response.json({ appointments }, { headers: corsHeaders });
      }

      // Webhook endpoints (no auth required, verified by signature)
      if (path.match(/^\/webhooks\/integrations\/[^/]+$/) && request.method === 'POST') {
        const match = path.match(/^\/webhooks\/integrations\/([^/]+)$/);
        const integrationType = match![1] as IntegrationType;

        return await webhookHandler.handleWebhook(integrationType, request);
      }

      // List available integrations
      if (path === '/integrations/available' && request.method === 'GET') {
        const types = ConnectorFactory.getSupportedTypes();
        const integrations = types.map(type => ConnectorFactory.getIntegrationInfo(type));

        return Response.json({ integrations }, { headers: corsHeaders });
      }

      return Response.json(
        { error: 'Not found' },
        { status: 404, headers: corsHeaders }
      );

    } catch (error) {
      console.error('Integration hub error:', error);

      return Response.json(
        { error: error.message },
        { status: 500, headers: corsHeaders }
      );
    }
  },

  // Queue consumer for sync jobs
  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    const syncEngine = new SyncEngine(env);

    for (const message of batch.messages) {
      try {
        const { integrationId, syncType } = message.body;

        await syncEngine.performSync(integrationId, syncType);

        // Schedule next recurring sync
        if (syncType === 'incremental') {
          await syncEngine.scheduleRecurringSync(integrationId, 24);
        }

        message.ack();

      } catch (error) {
        console.error('Sync job failed:', error);
        
        // Retry with exponential backoff
        message.retry();
      }
    }
  }
};
```

---

**This completes the Integration Hub implementation. Ready for the next section (Billing & Analytics, or Deployment & Configuration)?**
#vocalized