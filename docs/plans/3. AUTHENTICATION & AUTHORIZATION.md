---
tags:
  - vocalized
  - authentication
  - authorization
  - pipeline
---

## 3.1 Authentication Flow

### Admin Authentication

```typescript
// Admin Login Flow
// POST /admin/auth/login

interface AdminLoginRequest {
  email: string;
  password: string;
}

interface AdminLoginResponse {
  token: string; // JWT
  refresh_token: string;
  admin: {
    id: string;
    email: string;
    name: string;
    role: 'super_admin' | 'admin' | 'support';
  };
}

// Token Structure (JWT Payload)
interface AdminTokenPayload {
  type: 'admin';
  admin_id: string;
  role: string;
  iat: number; // issued at
  exp: number; // expires (24 hours)
}
```

### Client Authentication

```typescript
// Client Login Flow
// POST /auth/login

interface ClientLoginRequest {
  email: string;
  password: string;
}

interface ClientLoginResponse {
  token: string; // JWT
  refresh_token: string;
  user: {
    id: string;
    email: string;
    name: string;
  };
  workspaces: Array<{
    workspace_id: string;
    name: string;
    role: string;
  }>;
}

// Token Structure (JWT Payload)
interface ClientTokenPayload {
  type: 'client';
  user_id: string;
  workspace_ids: string[]; // All workspaces user has access to
  iat: number;
  exp: number; // expires (24 hours)
}
```

---

## 3.2 Authorization Middleware

```typescript
// Cloudflare Worker - Authorization Middleware

interface AuthContext {
  type: 'admin' | 'client';
  admin_id?: string;
  admin_role?: string;
  user_id?: string;
  workspace_ids?: string[];
}

async function authorize(
  request: Request, 
  env: Env
): Promise<AuthContext> {
  const authHeader = request.headers.get('Authorization');
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new UnauthorizedError('Missing or invalid authorization header');
  }

  const token = authHeader.substring(7);
  const path = new URL(request.url).pathname;

  // Verify JWT
  const payload = await verifyJWT(token, env.JWT_SECRET);

  if (path.startsWith('/admin/')) {
    // ADMIN ROUTES
    if (payload.type !== 'admin') {
      throw new ForbiddenError('Admin access required');
    }

    // Verify admin still exists and is active
    const admin = await env.DB
      .prepare('SELECT id, role, is_active FROM platform_admins WHERE id = ?')
      .bind(payload.admin_id)
      .first();

    if (!admin || !admin.is_active) {
      throw new UnauthorizedError('Admin account not found or inactive');
    }

    return {
      type: 'admin',
      admin_id: admin.id,
      admin_role: admin.role
    };

  } else {
    // CLIENT ROUTES
    if (payload.type !== 'client') {
      throw new ForbiddenError('Client access required');
    }

    // Verify user still exists and is active
    const user = await env.DB
      .prepare('SELECT id, is_active FROM client_users WHERE id = ?')
      .bind(payload.user_id)
      .first();

    if (!user || !user.is_active) {
      throw new UnauthorizedError('User account not found or inactive');
    }

    // Get fresh list of workspace_ids user has access to
    const workspaces = await env.DB
      .prepare('SELECT workspace_id FROM workspace_members WHERE user_id = ?')
      .bind(user.id)
      .all();

    return {
      type: 'client',
      user_id: user.id,
      workspace_ids: workspaces.results.map(w => w.workspace_id)
    };
  }
}

// Verify JWT
async function verifyJWT(token: string, secret: string): Promise<any> {
  try {
    // Use Cloudflare Workers JWT library or implement verification
    const decoded = await jwt.verify(token, secret);
    
    // Check expiration
    if (decoded.exp < Date.now() / 1000) {
      throw new UnauthorizedError('Token expired');
    }
    
    return decoded;
  } catch (error) {
    throw new UnauthorizedError('Invalid token');
  }
}
```

---

## 3.3 Workspace Access Control

```typescript
// Enforce workspace access for client users
async function enforceWorkspaceAccess(
  auth: AuthContext,
  workspaceId: string,
  requiredRole?: string[]
): Promise<void> {
  
  // Admins can access any workspace
  if (auth.type === 'admin') {
    return;
  }

  // Check if client user has access to this workspace
  if (!auth.workspace_ids?.includes(workspaceId)) {
    throw new ForbiddenError('Access denied to this workspace');
  }

  // If specific role is required, check it
  if (requiredRole && requiredRole.length > 0) {
    const member = await env.DB
      .prepare(
        'SELECT role FROM workspace_members WHERE workspace_id = ? AND user_id = ?'
      )
      .bind(workspaceId, auth.user_id)
      .first();

    if (!member || !requiredRole.includes(member.role)) {
      throw new ForbiddenError(`Required role: ${requiredRole.join(' or ')}`);
    }
  }
}

// Example usage in API handler
async function handleUpdateAgent(request: Request, env: Env) {
  const auth = await authorize(request, env);
  const { workspaceId, agentId } = getParams(request);
  
  // Only owner/admin can update agents
  await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);
  
  // Proceed with update...
}
```

---

## 3.4 Role-Based Permissions

### Admin Roles

```typescript
enum AdminRole {
  SUPER_ADMIN = 'super_admin', // You - full access
  ADMIN = 'admin',              // Can manage workspaces, view all data
  SUPPORT = 'support'           // Read-only access
}

// Permission checks
function canManageProviders(role: AdminRole): boolean {
  return role === AdminRole.SUPER_ADMIN;
}

function canSuspendWorkspace(role: AdminRole): boolean {
  return [AdminRole.SUPER_ADMIN, AdminRole.ADMIN].includes(role);
}

function canViewWorkspaceDetails(role: AdminRole): boolean {
  return true; // All admin roles can view
}

function canDeleteWorkspace(role: AdminRole): boolean {
  return role === AdminRole.SUPER_ADMIN;
}
```

### Client Roles

```typescript
enum WorkspaceRole {
  OWNER = 'owner',     // Full control, can delete workspace
  ADMIN = 'admin',     // Can manage agents, integrations, billing
  MEMBER = 'member',   // Can view calls, analytics, but not change settings
  VIEWER = 'viewer'    // Read-only access
}

// Permission checks
function canDeleteWorkspace(role: WorkspaceRole): boolean {
  return role === WorkspaceRole.OWNER;
}

function canManageAgents(role: WorkspaceRole): boolean {
  return [WorkspaceRole.OWNER, WorkspaceRole.ADMIN].includes(role);
}

function canManageBilling(role: WorkspaceRole): boolean {
  return [WorkspaceRole.OWNER, WorkspaceRole.ADMIN].includes(role);
}

function canInviteMembers(role: WorkspaceRole): boolean {
  return [WorkspaceRole.OWNER, WorkspaceRole.ADMIN].includes(role);
}

function canViewCalls(role: WorkspaceRole): boolean {
  return true; // All roles can view calls
}

function canUpdateWorkspaceSettings(role: WorkspaceRole): boolean {
  return [WorkspaceRole.OWNER, WorkspaceRole.ADMIN].includes(role);
}
```

---

## 3.5 API Handler with Authorization

```typescript
// Example: Complete API handler with authorization

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method;

    try {
      // Public routes (no auth required)
      if (path === '/auth/login' || path === '/auth/signup') {
        return handlePublicRoute(request, env);
      }

      // All other routes require authentication
      const auth = await authorize(request, env);

      // Route to appropriate handler
      if (path.startsWith('/admin/')) {
        return handleAdminRoute(request, env, auth);
      } else {
        return handleClientRoute(request, env, auth);
      }

    } catch (error) {
      if (error instanceof UnauthorizedError) {
        return Response.json({ error: error.message }, { status: 401 });
      }
      if (error instanceof ForbiddenError) {
        return Response.json({ error: error.message }, { status: 403 });
      }
      return Response.json({ error: 'Internal server error' }, { status: 500 });
    }
  }
};

async function handleClientRoute(
  request: Request,
  env: Env,
  auth: AuthContext
): Promise<Response> {
  const url = new URL(request.url);
  const path = url.pathname;
  const method = request.method;

  // Example: GET /workspaces/{workspaceId}/agents
  const agentsMatch = path.match(/^\/workspaces\/([^\/]+)\/agents$/);
  
  if (agentsMatch && method === 'GET') {
    const workspaceId = agentsMatch[1];
    
    // Check workspace access
    await enforceWorkspaceAccess(auth, workspaceId);
    
    // Fetch agents
    const agents = await env.DB
      .prepare('SELECT * FROM voice_agents WHERE workspace_id = ?')
      .bind(workspaceId)
      .all();

    return Response.json({ agents: agents.results });
  }

  // Example: POST /workspaces/{workspaceId}/agents
  if (agentsMatch && method === 'POST') {
    const workspaceId = agentsMatch[1];
    
    // Check workspace access with required role
    await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);
    
    const body = await request.json();
    
    // Create agent...
    const agentId = crypto.randomUUID();
    await env.DB
      .prepare(`
        INSERT INTO voice_agents 
        (id, workspace_id, name, config, voice_provider, voice_config, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        agentId,
        workspaceId,
        body.name,
        JSON.stringify(body.config),
        body.voice_provider,
        JSON.stringify(body.voice_config),
        Date.now(),
        Date.now()
      )
      .run();

    // Log activity
    await logClientActivity(auth.user_id, 'created_agent', agentId, env);

    return Response.json({ agent: { id: agentId, ...body } });
  }

  return Response.json({ error: 'Not found' }, { status: 404 });
}

async function handleAdminRoute(
  request: Request,
  env: Env,
  auth: AuthContext
): Promise<Response> {
  const url = new URL(request.url);
  const path = url.pathname;
  const method = request.method;

  // Example: GET /admin/workspaces
  if (path === '/admin/workspaces' && method === 'GET') {
    const workspaces = await env.DB
      .prepare(`
        SELECT w.*, u.email as owner_email 
        FROM workspaces w
        JOIN client_users u ON w.owner_id = u.id
        ORDER BY w.created_at DESC
      `)
      .all();

    // Log admin activity
    await logAdminActivity(
      auth.admin_id,
      'viewed_workspaces_list',
      null,
      null,
      request.headers.get('CF-Connecting-IP'),
      env
    );

    return Response.json({ workspaces: workspaces.results });
  }

  // Example: POST /admin/workspaces/{workspaceId}/suspend
  const suspendMatch = path.match(/^\/admin\/workspaces\/([^\/]+)\/suspend$/);
  
  if (suspendMatch && method === 'POST') {
    const workspaceId = suspendMatch[1];
    
    // Check admin role (only super_admin and admin can suspend)
    if (!canSuspendWorkspace(auth.admin_role)) {
      throw new ForbiddenError('Insufficient permissions');
    }

    const body = await request.json();
    
    await env.DB
      .prepare('UPDATE workspaces SET status = ?, updated_at = ? WHERE id = ?')
      .bind('suspended', Date.now(), workspaceId)
      .run();

    // Log admin activity
    await logAdminActivity(
      auth.admin_id,
      'suspended_workspace',
      'workspace',
      workspaceId,
      request.headers.get('CF-Connecting-IP'),
      env,
      { reason: body.reason }
    );

    return Response.json({ success: true });
  }

  return Response.json({ error: 'Not found' }, { status: 404 });
}

// Activity logging
async function logAdminActivity(
  adminId: string,
  action: string,
  resourceType: string | null,
  resourceId: string | null,
  ipAddress: string | null,
  env: Env,
  details?: any
): Promise<void> {
  await env.DB
    .prepare(`
      INSERT INTO admin_activity_logs 
      (id, admin_id, action, resource_type, resource_id, details, ip_address, timestamp)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `)
    .bind(
      crypto.randomUUID(),
      adminId,
      action,
      resourceType,
      resourceId,
      details ? JSON.stringify(details) : null,
      ipAddress,
      Date.now()
    )
    .run();
}

async function logClientActivity(
  userId: string,
  action: string,
  resourceId: string | null,
  env: Env
): Promise<void> {
  // Optional: Log client activity if needed
  // Could create a separate client_activity_logs table
}

// Custom error classes
class UnauthorizedError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UnauthorizedError';
  }
}

class ForbiddenError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ForbiddenError';
  }
}
```

---

## 3.6 Password Hashing

```typescript
// Password hashing using Web Crypto API (available in Cloudflare Workers)

async function hashPassword(password: string): Promise<string> {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const passwordBuffer = new TextEncoder().encode(password);
  
  const key = await crypto.subtle.importKey(
    'raw',
    passwordBuffer,
    { name: 'PBKDF2' },
    false,
    ['deriveBits']
  );

  const hashBuffer = await crypto.subtle.deriveBits(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    key,
    256
  );

  // Combine salt + hash
  const combined = new Uint8Array(salt.length + hashBuffer.byteLength);
  combined.set(salt, 0);
  combined.set(new Uint8Array(hashBuffer), salt.length);

  // Return as base64
  return btoa(String.fromCharCode(...combined));
}

async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  // Decode base64
  const combined = Uint8Array.from(atob(hashedPassword), c => c.charCodeAt(0));
  
  // Extract salt and hash
  const salt = combined.slice(0, 16);
  const storedHash = combined.slice(16);

  // Hash the provided password with the same salt
  const passwordBuffer = new TextEncoder().encode(password);
  
  const key = await crypto.subtle.importKey(
    'raw',
    passwordBuffer,
    { name: 'PBKDF2' },
    false,
    ['deriveBits']
  );

  const hashBuffer = await crypto.subtle.deriveBits(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    key,
    256
  );

  const computedHash = new Uint8Array(hashBuffer);

  // Compare hashes (constant-time comparison)
  if (computedHash.length !== storedHash.length) {
    return false;
  }

  let result = 0;
  for (let i = 0; i < computedHash.length; i++) {
    result |= computedHash[i] ^ storedHash[i];
  }

  return result === 0;
}

// Usage in signup
async function handleSignup(request: Request, env: Env): Promise<Response> {
  const { email, password, name } = await request.json();

  // Validate password strength
  if (password.length < 8) {
    return Response.json(
      { error: 'Password must be at least 8 characters' },
      { status: 400 }
    );
  }

  // Check if email already exists
  const existing = await env.DB
    .prepare('SELECT id FROM client_users WHERE email = ?')
    .bind(email)
    .first();

  if (existing) {
    return Response.json(
      { error: 'Email already registered' },
      { status: 409 }
    );
  }

  // Hash password
  const passwordHash = await hashPassword(password);

  // Create user
  const userId = crypto.randomUUID();
  await env.DB
    .prepare(`
      INSERT INTO client_users 
      (id, email, name, password_hash, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `)
    .bind(userId, email, name, passwordHash, Date.now(), Date.now())
    .run();

  // Generate JWT
  const token = await generateJWT(
    { type: 'client', user_id: userId },
    env.JWT_SECRET
  );

  return Response.json({
    token,
    user: { id: userId, email, name }
  });
}

// Usage in login
async function handleLogin(request: Request, env: Env): Promise<Response> {
  const { email, password } = await request.json();

  // Find user
  const user = await env.DB
    .prepare('SELECT id, email, name, password_hash, is_active FROM client_users WHERE email = ?')
    .bind(email)
    .first();

  if (!user) {
    return Response.json(
      { error: 'Invalid credentials' },
      { status: 401 }
    );
  }

  if (!user.is_active) {
    return Response.json(
      { error: 'Account is inactive' },
      { status: 403 }
    );
  }

  // Verify password
  const isValid = await verifyPassword(password, user.password_hash);

  if (!isValid) {
    return Response.json(
      { error: 'Invalid credentials' },
      { status: 401 }
    );
  }

  // Get user's workspaces
  const workspaces = await env.DB
    .prepare(`
      SELECT wm.workspace_id, w.name, wm.role 
      FROM workspace_members wm
      JOIN workspaces w ON wm.workspace_id = w.id
      WHERE wm.user_id = ?
    `)
    .bind(user.id)
    .all();

  // Update last_login
  await env.DB
    .prepare('UPDATE client_users SET last_login = ? WHERE id = ?')
    .bind(Date.now(), user.id)
    .run();

  // Generate JWT
  const token = await generateJWT(
    {
      type: 'client',
      user_id: user.id,
      workspace_ids: workspaces.results.map(w => w.workspace_id)
    },
    env.JWT_SECRET,
    '24h'
  );

  return Response.json({
    token,
    user: { id: user.id, email: user.email, name: user.name },
    workspaces: workspaces.results
  });
}
```

---

## 3.7 JWT Generation

```typescript
// JWT generation using jose library (works in Cloudflare Workers)
import * as jose from 'jose';

async function generateJWT(
  payload: any,
  secret: string,
  expiresIn: string = '24h'
): Promise<string> {
  const secretKey = new TextEncoder().encode(secret);
  
  const jwt = await new jose.SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime(expiresIn)
    .sign(secretKey);

  return jwt;
}

async function verifyJWT(token: string, secret: string): Promise<any> {
  const secretKey = new TextEncoder().encode(secret);
  
  try {
    const { payload } = await jose.jwtVerify(token, secretKey);
    return payload;
  } catch (error) {
    throw new UnauthorizedError('Invalid or expired token');
  }
}
```

---

## 3.8 Environment Variables

```toml
# wrangler.toml

[vars]
# These will be available as env.JWT_SECRET, etc.

# Development
[env.development]
vars = { ENVIRONMENT = "development" }

[env.development.vars]
JWT_SECRET = "dev-secret-change-in-production"

# Production
[env.production]
vars = { ENVIRONMENT = "production" }

# Secrets (use: wrangler secret put JWT_SECRET)
# JWT_SECRET - stored as Cloudflare secret
# STRIPE_SECRET_KEY - stored as secret
# TWILIO_AUTH_TOKEN - stored as secret
```

```bash
# Set secrets in Cloudflare
wrangler secret put JWT_SECRET
wrangler secret put STRIPE_SECRET_KEY
wrangler secret put TWILIO_AUTH_TOKEN
```

---

**This completes the Authentication & Authorization section. Ready for the next section?**
#vocalized