---
tags:
  - pipeline
  - analytics
  - billing
---
## 7.5 Analytics Engine

```typescript
// ============================================
// ANALYTICS ENGINE
// Comprehensive analytics and metrics
// ============================================

class AnalyticsEngine {
  constructor(private env: Env) {}

  // ==========================================
  // WORKSPACE ANALYTICS
  // ==========================================

  async getWorkspaceOverview(
    workspaceId: string,
    period: 'day' | 'week' | 'month' | 'year' = 'month'
  ): Promise<{
    calls: {
      total: number;
      completed: number;
      failed: number;
      avgDuration: number;
      totalMinutes: number;
    };
    cost: {
      total: number;
      byProvider: Record<string, number>;
      trend: Array<{ date: string; cost: number }>;
    };
    performance: {
      successRate: number;
      avgResponseTime: number;
      sentiment: {
        positive: number;
        neutral: number;
        negative: number;
      };
    };
  }> {
    
    const { startTime, endTime } = this.getPeriodRange(period);

    // Call statistics
    const callStats = await this.env.DB
      .prepare(`
        SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
          AVG(duration_seconds) as avg_duration,
          SUM(duration_seconds) as total_seconds
        FROM calls
        WHERE workspace_id = ? AND started_at >= ? AND started_at <= ?
      `)
      .bind(workspaceId, startTime, endTime)
      .first();

    // Cost breakdown
    const costByProvider = await this.env.DB
      .prepare(`
        SELECT 
          provider,
          SUM(final_cost) as cost
        FROM usage_records
        WHERE workspace_id = ? AND created_at >= ? AND created_at <= ?
        GROUP BY provider
      `)
      .bind(workspaceId, startTime, endTime)
      .all();

    // Cost trend (daily)
    const costTrend = await this.getCostTrend(workspaceId, startTime, endTime);

    // Sentiment analysis
    const sentiment = await this.env.DB
      .prepare(`
        SELECT 
          sentiment,
          COUNT(*) as count
        FROM calls
        WHERE workspace_id = ? 
        AND started_at >= ? 
        AND started_at <= ?
        AND sentiment IS NOT NULL
        GROUP BY sentiment
      `)
      .bind(workspaceId, startTime, endTime)
      .all();

    const sentimentMap = {
      positive: 0,
      neutral: 0,
      negative: 0
    };

    for (const row of sentiment.results) {
      if (row.sentiment in sentimentMap) {
        sentimentMap[row.sentiment] = row.count;
      }
    }

    const totalSentiment = Object.values(sentimentMap).reduce((a, b) => a + b, 0);

    return {
      calls: {
        total: callStats?.total || 0,
        completed: callStats?.completed || 0,
        failed: callStats?.failed || 0,
        avgDuration: Math.round(callStats?.avg_duration || 0),
        totalMinutes: Math.round((callStats?.total_seconds || 0) / 60)
      },
      cost: {
        total: costByProvider.results.reduce((sum, r) => sum + r.cost, 0),
        byProvider: Object.fromEntries(
          costByProvider.results.map(r => [r.provider, r.cost])
        ),
        trend: costTrend
      },
      performance: {
        successRate: callStats?.total 
          ? ((callStats.completed / callStats.total) * 100)
          : 0,
        avgResponseTime: 0, // Would need to track this separately
        sentiment: totalSentiment > 0 ? {
          positive: (sentimentMap.positive / totalSentiment) * 100,
          neutral: (sentimentMap.neutral / totalSentiment) * 100,
          negative: (sentimentMap.negative / totalSentiment) * 100
        } : { positive: 0, neutral: 0, negative: 0 }
      }
    };
  }

  async getCallAnalytics(
    workspaceId: string,
    filters?: {
      agentId?: string;
      status?: string;
      direction?: string;
      startDate?: number;
      endDate?: number;
    }
  ): Promise<{
    totalCalls: number;
    callsByStatus: Record<string, number>;
    callsByDirection: Record<string, number>;
    callsByAgent: Array<{ agentId: string; agentName: string; count: number }>;
    callsByHour: Array<{ hour: number; count: number }>;
    avgDuration: number;
    longestCall: number;
    shortestCall: number;
  }> {
    
    // Build query with filters
    let query = `
      SELECT 
        COUNT(*) as total_calls,
        AVG(duration_seconds) as avg_duration,
        MAX(duration_seconds) as longest_call,
        MIN(duration_seconds) as shortest_call
      FROM calls
      WHERE workspace_id = ?
    `;

    const params = [workspaceId];

    if (filters?.agentId) {
      query += ` AND agent_id = ?`;
      params.push(filters.agentId);
    }

    if (filters?.status) {
      query += ` AND status = ?`;
      params.push(filters.status);
    }

    if (filters?.direction) {
      query += ` AND direction = ?`;
      params.push(filters.direction);
    }

    if (filters?.startDate) {
      query += ` AND started_at >= ?`;
      params.push(filters.startDate.toString());
    }

    if (filters?.endDate) {
      query += ` AND started_at <= ?`;
      params.push(filters.endDate.toString());
    }

    const stats = await this.env.DB
      .prepare(query)
      .bind(...params)
      .first();

    // Calls by status
    const byStatus = await this.env.DB
      .prepare(`
        SELECT status, COUNT(*) as count
        FROM calls
        WHERE workspace_id = ?
        ${filters?.startDate ? 'AND started_at >= ?' : ''}
        ${filters?.endDate ? 'AND started_at <= ?' : ''}
        GROUP BY status
      `)
      .bind(
        workspaceId,
        ...(filters?.startDate ? [filters.startDate] : []),
        ...(filters?.endDate ? [filters.endDate] : [])
      )
      .all();

    // Calls by direction
    const byDirection = await this.env.DB
      .prepare(`
        SELECT direction, COUNT(*) as count
        FROM calls
        WHERE workspace_id = ?
        ${filters?.startDate ? 'AND started_at >= ?' : ''}
        ${filters?.endDate ? 'AND started_at <= ?' : ''}
        GROUP BY direction
      `)
      .bind(
        workspaceId,
        ...(filters?.startDate ? [filters.startDate] : []),
        ...(filters?.endDate ? [filters.endDate] : [])
      )
      .all();

    // Calls by agent
    const byAgent = await this.env.DB
      .prepare(`
        SELECT 
          c.agent_id,
          a.name as agent_name,
          COUNT(*) as count
        FROM calls c
        JOIN voice_agents a ON c.agent_id = a.id
        WHERE c.workspace_id = ?
        ${filters?.startDate ? 'AND c.started_at >= ?' : ''}
        ${filters?.endDate ? 'AND c.started_at <= ?' : ''}
        GROUP BY c.agent_id, a.name
        ORDER BY count DESC
      `)
      .bind(
        workspaceId,
        ...(filters?.startDate ? [filters.startDate] : []),
        ...(filters?.endDate ? [filters.endDate] : [])
      )
      .all();

    // Calls by hour
    const byHour = await this.env.DB
      .prepare(`
        SELECT 
          CAST((started_at / 3600000) % 24 AS INTEGER) as hour,
          COUNT(*) as count
        FROM calls
        WHERE workspace_id = ?
        ${filters?.startDate ? 'AND started_at >= ?' : ''}
        ${filters?.endDate ? 'AND started_at <= ?' : ''}
        GROUP BY hour
        ORDER BY hour
      `)
      .bind(
        workspaceId,
        ...(filters?.startDate ? [filters.startDate] : []),
        ...(filters?.endDate ? [filters.endDate] : [])
      )
      .all();

    return {
      totalCalls: stats?.total_calls || 0,
      callsByStatus: Object.fromEntries(
        byStatus.results.map(r => [r.status, r.count])
      ),
      callsByDirection: Object.fromEntries(
        byDirection.results.map(r => [r.direction, r.count])
      ),
      callsByAgent: byAgent.results.map(r => ({
        agentId: r.agent_id,
        agentName: r.agent_name,
        count: r.count
      })),
      callsByHour: byHour.results.map(r => ({
        hour: r.hour,
        count: r.count
      })),
      avgDuration: Math.round(stats?.avg_duration || 0),
      longestCall: stats?.longest_call || 0,
      shortestCall: stats?.shortest_call || 0
    };
  }

  async getAgentPerformance(
    agentId: string,
    period: 'day' | 'week' | 'month' = 'month'
  ): Promise<{
    totalCalls: number;
    successRate: number;
    avgDuration: number;
    totalMinutes: number;
    sentiment: {
      positive: number;
      neutral: number;
      negative: number;
    };
    topIntents: Array<{ intent: string; count: number }>;
    callTrend: Array<{ date: string; count: number }>;
  }> {
    
    const { startTime, endTime } = this.getPeriodRange(period);

    // Basic stats
    const stats = await this.env.DB
      .prepare(`
        SELECT 
          COUNT(*) as total_calls,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
          AVG(duration_seconds) as avg_duration,
          SUM(duration_seconds) as total_seconds
        FROM calls
        WHERE agent_id = ? AND started_at >= ? AND started_at <= ?
      `)
      .bind(agentId, startTime, endTime)
      .first();

    // Sentiment breakdown
    const sentiment = await this.env.DB
      .prepare(`
        SELECT 
          sentiment,
          COUNT(*) as count
        FROM calls
        WHERE agent_id = ? 
        AND started_at >= ? 
        AND started_at <= ?
        AND sentiment IS NOT NULL
        GROUP BY sentiment
      `)
      .bind(agentId, startTime, endTime)
      .all();

    const sentimentMap = {
      positive: 0,
      neutral: 0,
      negative: 0
    };

    for (const row of sentiment.results) {
      if (row.sentiment in sentimentMap) {
        sentimentMap[row.sentiment] = row.count;
      }
    }

    const totalSentiment = Object.values(sentimentMap).reduce((a, b) => a + b, 0);

    // Top intents (would need to track this in call metadata)
    const topIntents = await this.env.DB
      .prepare(`
        SELECT 
          json_extract(metadata, '$.intent') as intent,
          COUNT(*) as count
        FROM calls
        WHERE agent_id = ? 
        AND started_at >= ? 
        AND started_at <= ?
        AND json_extract(metadata, '$.intent') IS NOT NULL
        GROUP BY intent
        ORDER BY count DESC
        LIMIT 5
      `)
      .bind(agentId, startTime, endTime)
      .all();

    // Call trend (daily)
    const callTrend = await this.getCallTrend(agentId, startTime, endTime);

    return {
      totalCalls: stats?.total_calls || 0,
      successRate: stats?.total_calls 
        ? ((stats.completed / stats.total_calls) * 100)
        : 0,
      avgDuration: Math.round(stats?.avg_duration || 0),
      totalMinutes: Math.round((stats?.total_seconds || 0) / 60),
      sentiment: totalSentiment > 0 ? {
        positive: (sentimentMap.positive / totalSentiment) * 100,
        neutral: (sentimentMap.neutral / totalSentiment) * 100,
        negative: (sentimentMap.negative / totalSentiment) * 100
      } : { positive: 0, neutral: 0, negative: 0 },
      topIntents: topIntents.results.map(r => ({
        intent: r.intent,
        count: r.count
      })),
      callTrend
    };
  }

  // ==========================================
  // ADMIN ANALYTICS (Platform-wide)
  // ==========================================

  async getPlatformOverview(): Promise<{
    totalWorkspaces: number;
    activeWorkspaces: number;
    totalCalls: number;
    totalRevenue: number;
    mrr: number;
    churnRate: number;
    topWorkspaces: Array<{
      workspaceId: string;
      name: string;
      calls: number;
      revenue: number;
    }>;
  }> {
    
    // Total workspaces
    const workspaceStats = await this.env.DB
      .prepare(`
        SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active
        FROM workspaces
      `)
      .first();

    // Total calls (last 30 days)
    const now = Date.now();
    const thirtyDaysAgo = now - (30 * 24 * 60 * 60 * 1000);

    const callStats = await this.env.DB
      .prepare(`
        SELECT COUNT(*) as total
        FROM calls
        WHERE started_at >= ?
      `)
      .bind(thirtyDaysAgo)
      .first();

    // Total revenue (last 30 days)
    const revenueStats = await this.env.DB
      .prepare(`
        SELECT SUM(total_amount) as total
        FROM billing_periods
        WHERE status IN ('paid', 'finalized')
        AND period_start >= ?
      `)
      .bind(thirtyDaysAgo)
      .first();

    // MRR (Monthly Recurring Revenue)
    const mrrStats = await this.env.DB
      .prepare(`
        SELECT SUM(monthly_fee) as mrr
        FROM subscription_tiers st
        JOIN workspaces w ON st.tier_name = w.subscription_tier
        WHERE w.status = 'active'
      `)
      .first();

    // Churn rate (last 30 days)
    const churnStats = await this.env.DB
      .prepare(`
        SELECT 
          COUNT(*) as churned
        FROM workspaces
        WHERE status = 'cancelled'
        AND updated_at >= ?
      `)
      .bind(thirtyDaysAgo)
      .first();

    const churnRate = workspaceStats?.total 
      ? ((churnStats?.churned || 0) / workspaceStats.total) * 100
      : 0;

    // Top workspaces
    const topWorkspaces = await this.env.DB
      .prepare(`
        SELECT 
          w.id as workspace_id,
          w.name,
          COUNT(c.id) as calls,
          COALESCE(SUM(bp.total_amount), 0) as revenue
        FROM workspaces w
        LEFT JOIN calls c ON w.id = c.workspace_id AND c.started_at >= ?
        LEFT JOIN billing_periods bp ON w.id = bp.workspace_id AND bp.status = 'paid'
        GROUP BY w.id, w.name
        ORDER BY revenue DESC
        LIMIT 10
      `)
      .bind(thirtyDaysAgo)
      .all();

    return {
      totalWorkspaces: workspaceStats?.total || 0,
      activeWorkspaces: workspaceStats?.active || 0,
      totalCalls: callStats?.total || 0,
      totalRevenue: revenueStats?.total || 0,
      mrr: mrrStats?.mrr || 0,
      churnRate,
      topWorkspaces: topWorkspaces.results.map(r => ({
        workspaceId: r.workspace_id,
        name: r.name,
        calls: r.calls,
        revenue: r.revenue
      }))
    };
  }

  async getProviderAnalytics(
    period: 'day' | 'week' | 'month' = 'month'
  ): Promise<Array<{
    provider: string;
    totalCalls: number;
    successRate: number;
    avgLatency: number;
    totalCost: number;
    totalRevenue: number;
    profitMargin: number;
  }>> {
    
    const { startTime, endTime } = this.getPeriodRange(period);

    // Get provider statistics
    const stats = await this.env.DB
      .prepare(`
        SELECT 
          c.voice_provider_used as provider,
          COUNT(*) as total_calls,
          SUM(CASE WHEN c.status = 'completed' THEN 1 ELSE 0 END) as completed_calls,
          SUM(u.total_cost) as total_cost,
          SUM(u.final_cost) as total_revenue
        FROM calls c
        LEFT JOIN usage_records u ON c.id = u.call_id
        WHERE c.started_at >= ? AND c.started_at <= ?
        GROUP BY c.voice_provider_used
      `)
      .bind(startTime, endTime)
      .all();

    // Get average latency from provider health
    const latencyStats = await this.env.DB
      .prepare(`
        SELECT 
          provider,
          AVG(avg_latency) as avg_latency
        FROM provider_health_status
        WHERE last_check >= ? AND last_check <= ?
        GROUP BY provider
      `)
      .bind(startTime, endTime)
      .all();

    const latencyMap = Object.fromEntries(
      latencyStats.results.map(r => [r.provider, r.avg_latency])
    );

    return stats.results.map(r => {
      const successRate = r.total_calls 
        ? (r.completed_calls / r.total_calls) * 100
        : 0;

      const profitMargin = r.total_revenue && r.total_cost
        ? ((r.total_revenue - r.total_cost) / r.total_revenue) * 100
        : 0;

      return {
        provider: r.provider,
        totalCalls: r.total_calls,
        successRate,
        avgLatency: latencyMap[r.provider] || 0,
        totalCost: r.total_cost || 0,
        totalRevenue: r.total_revenue || 0,
        profitMargin
      };
    });
  }

  // ==========================================
  // HELPER METHODS
  // ==========================================

  private getPeriodRange(period: 'day' | 'week' | 'month' | 'year'): {
    startTime: number;
    endTime: number;
  } {
    const now = Date.now();
    let startTime: number;

    switch (period) {
      case 'day':
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        startTime = today.getTime();
        break;

      case 'week':
        startTime = now - (7 * 24 * 60 * 60 * 1000);
        break;

      case 'month':
        startTime = now - (30 * 24 * 60 * 60 * 1000);
        break;

      case 'year':
        startTime = now - (365 * 24 * 60 * 60 * 1000);
        break;
    }

    return { startTime, endTime: now };
  }

  private async getCostTrend(
    workspaceId: string,
    startTime: number,
    endTime: number
  ): Promise<Array<{ date: string; cost: number }>> {
    
    const trend = await this.env.DB
      .prepare(`
        SELECT 
          DATE(created_at / 1000, 'unixepoch') as date,
          SUM(final_cost) as cost
        FROM usage_records
        WHERE workspace_id = ? 
        AND created_at >= ? 
        AND created_at <= ?
        GROUP BY date
        ORDER BY date
      `)
      .bind(workspaceId, startTime, endTime)
      .all();

    return trend.results.map(r => ({
      date: r.date,
      cost: r.cost
    }));
  }

  private async getCallTrend(
    agentId: string,
    startTime: number,
    endTime: number
  ): Promise<Array<{ date: string; count: number }>> {
    
    const trend = await this.env.DB
      .prepare(`
        SELECT 
          DATE(started_at / 1000, 'unixepoch') as date,
          COUNT(*) as count
        FROM calls
        WHERE agent_id = ? 
        AND started_at >= ? 
        AND started_at <= ?
        GROUP BY date
        ORDER BY date
      `)
      .bind(agentId, startTime, endTime)
      .all();

    return trend.results.map(r => ({
      date: r.date,
      count: r.count
    }));
  }

  async exportAnalytics(
    workspaceId: string,
    format: 'csv' | 'json',
    startDate: number,
    endDate: number
  ): Promise<string> {
    
    // Get all calls in period
    const calls = await this.env.DB
      .prepare(`
        SELECT 
          c.*,
          a.name as agent_name
        FROM calls c
        JOIN voice_agents a ON c.agent_id = a.id
        WHERE c.workspace_id = ? 
        AND c.started_at >= ? 
        AND c.started_at <= ?
        ORDER BY c.started_at DESC
      `)
      .bind(workspaceId, startDate, endDate)
      .all();

    if (format === 'json') {
      return JSON.stringify(calls.results, null, 2);
    }

    // CSV format
    const headers = [
      'Call ID',
      'Agent',
      'Caller',
      'Direction',
      'Status',
      'Duration (seconds)',
      'Cost',
      'Started At',
      'Ended At'
    ];

    const rows = calls.results.map(call => [
      call.id,
      call.agent_name,
      call.caller_number,
      call.direction,
      call.status,
      call.duration_seconds || 0,
      call.cost_total || 0,
      new Date(call.started_at).toISOString(),
      call.ended_at ? new Date(call.ended_at).toISOString() : ''
    ]);

    const csv = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');

    return csv;
  }
}
```

---

## 7.6 Report Generator

```typescript
// ============================================
// REPORT GENERATOR
// Generate various reports
// ============================================

class ReportGenerator {
  constructor(
    private env: Env,
    private analytics: AnalyticsEngine
  ) {}

  async generateMonthlyReport(
    workspaceId: string,
    year: number,
    month: number
  ): Promise<{
    workspace: any;
    period: { start: string; end: string };
    summary: any;
    details: any;
    charts: any;
  }> {
    
    // Get workspace info
    const workspace = await this.env.DB
      .prepare(`SELECT * FROM workspaces WHERE id = ?`)
      .bind(workspaceId)
      .first();

    // Define period
    const periodStart = new Date(year, month - 1, 1);
    const periodEnd = new Date(year, month, 0);
    periodEnd.setHours(23, 59, 59, 999);

    // Get analytics
    const overview = await this.analytics.getWorkspaceOverview(
      workspaceId,
      'month'
    );

    const callAnalytics = await this.analytics.getCallAnalytics(workspaceId, {
      startDate: periodStart.getTime(),
      endDate: periodEnd.getTime()
    });

    // Get cost breakdown
    const usageTracker = new UsageTracker(this.env);
    const billingPeriod = await this.env.DB
      .prepare(`
        SELECT id FROM billing_periods
        WHERE workspace_id = ? 
        AND period_start >= ? 
        AND period_end <= ?
      `)
      .bind(workspaceId, periodStart.getTime(), periodEnd.getTime())
      .first();

    const costBreakdown = billingPeriod
      ? await usageTracker.getUsageSummary(workspaceId, billingPeriod.id)
      : null;

    return {
      workspace: {
        id: workspace.id,
        name: workspace.name,
        industry: workspace.industry
      },
      period: {
        start: periodStart.toISOString(),
        end: periodEnd.toISOString()
      },
      summary: {
        totalCalls: overview.calls.total,
        totalMinutes: overview.calls.totalMinutes,
        successRate: overview.performance.successRate,
        totalCost: overview.cost.total
      },
      details: {
        calls: callAnalytics,
        costs: costBreakdown
      },
      charts: {
        callsByHour: callAnalytics.callsByHour,
        callsByAgent: callAnalytics.callsByAgent,
        costTrend: overview.cost.trend
      }
    };
  }

  async generateExecutiveSummary(
    workspaceId: string,
    quarter: number,
    year: number
  ): Promise<string> {
    
    // Get quarterly data
    const quarterStart = new Date(year, (quarter - 1) * 3, 1);
    const quarterEnd = new Date(year, quarter * 3, 0);
    quarterEnd.setHours(23, 59, 59, 999);

    const overview = await this.analytics.getWorkspaceOverview(
      workspaceId,
      'month'
    );

    const callAnalytics = await this.analytics.getCallAnalytics(workspaceId, {
      startDate: quarterStart.getTime(),
      endDate: quarterEnd.getTime()
    });

    // Generate markdown report
    const report = `
# Executive Summary - Q${quarter} ${year}

## Key Metrics

- **Total Calls**: ${callAnalytics.totalCalls.toLocaleString()}
- **Success Rate**: ${overview.performance.successRate.toFixed(1)}%
- **Total Minutes**: ${overview.calls.totalMinutes.toLocaleString()}
- **Total Cost**: $${overview.cost.total.toFixed(2)}

## Call Performance

- **Average Duration**: ${callAnalytics.avgDuration} seconds
- **Longest Call**: ${callAnalytics.longestCall} seconds
- **Inbound Calls**: ${callAnalytics.callsByDirection.inbound || 0}
- **Outbound Calls**: ${callAnalytics.callsByDirection.outbound || 0}

## Agent Performance

${callAnalytics.callsByAgent.map(agent => 
  `- **${agent.agentName}**: ${agent.count} calls`
).join('\n')}

## Sentiment Analysis

- **Positive**: ${overview.performance.sentiment.positive.toFixed(1)}%
- **Neutral**: ${overview.performance.sentiment.neutral.toFixed(1)}%
- **Negative**: ${overview.performance.sentiment.negative.toFixed(1)}%

## Cost Breakdown by Provider

${Object.entries(overview.cost.byProvider).map(([provider, cost]) =>
  `- **${provider}**: $${cost.toFixed(2)}`
).join('\n')}

## Peak Call Hours

${callAnalytics.callsByHour
  .sort((a, b) => b.count - a.count)
  .slice(0, 5)
  .map((hour, idx) => 
    `${idx + 1}. ${hour.hour}:00 - ${hour.count} calls`
  ).join('\n')}
`;

    return report;
  }
}
```

---

**Continue with Part 3 of Billing & Analytics (Billing & Analytics Worker, Scheduled Jobs)?**
#vocalized