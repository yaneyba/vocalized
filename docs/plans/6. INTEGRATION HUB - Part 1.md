---
tags:
  - vocalized
  - integration
  - integration-hub
  - pipeline
---
## 6.1 Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    Integration Hub                          │
│                                                             │
│  ┌──────────────┐         ┌──────────────┐                  │
│  │   OAuth      │         │  Integration │                  │
│  │   Manager    │────────▶│  Registry    │                  │
│  └──────────────┘         └──────────────┘                  │
│         │                          │                        │
│         │                          ▼                        │
│         │                  ┌──────────────┐                 │
│         │                  │   Connector  │                 │
│         │                  │   Factory    │                 │
│         │                  └──────────────┘                 │
│         │                          │                        │
│         ▼                          ▼                        │
│  ┌─────────────────────────────────────────┐                │
│  │        Integration Connectors           │                │
│  │  ┌────────┐ ┌────────┐ ┌──────────┐     │                │
│  │  │Salesfrc│ │HubSpot │ │G Calendar│     │                │
│  │  ├────────┤ ├────────┤ ├──────────┤     │                │
│  │  │ Square │ │ Fresha │ │ Outlook  │     │                │
│  │  └────────┘ └────────┘ └──────────┘     │                │
│  └─────────────────────────────────────────┘                │
│         │                          │                        │
│         ▼                          ▼                        │
│  ┌──────────────┐         ┌──────────────┐                  │
│  │   Sync       │         │   Webhook    │                  │
│  │   Engine     │         │   Handler    │                  │
│  └──────────────┘         └──────────────┘                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 6.2 Core Types

```typescript
// ============================================
// INTEGRATION HUB TYPES
// ============================================

interface IntegrationConnector {
  type: string;
  name: string;
  
  // OAuth flow
  getAuthUrl(workspaceId: string, redirectUri: string): string;
  exchangeCode(code: string, redirectUri: string): Promise<OAuthTokens>;
  refreshToken(refreshToken: string): Promise<OAuthTokens>;
  
  // API operations
  testConnection(credentials: IntegrationCredentials): Promise<boolean>;
  syncData(credentials: IntegrationCredentials, config: SyncConfig): Promise<SyncResult>;
  
  // Specific actions
  createAppointment?(credentials: IntegrationCredentials, data: AppointmentData): Promise<any>;
  getAvailability?(credentials: IntegrationCredentials, params: any): Promise<any>;
  lookupContact?(credentials: IntegrationCredentials, identifier: string): Promise<any>;
  createContact?(credentials: IntegrationCredentials, data: ContactData): Promise<any>;
}

interface OAuthTokens {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
  tokenType: string;
  scope?: string;
}

interface IntegrationCredentials {
  accessToken: string;
  refreshToken?: string;
  expiresAt?: number;
  metadata?: Record<string, any>;
}

interface SyncConfig {
  direction: 'pull' | 'push' | 'bidirectional';
  resources: string[]; // e.g., ['contacts', 'appointments']
  filters?: Record<string, any>;
  lastSyncAt?: number;
}

interface SyncResult {
  success: boolean;
  recordsSynced: number;
  errors?: Array<{ record: any; error: string }>;
  nextSyncToken?: string;
}

interface AppointmentData {
  serviceId?: string;
  staffId?: string;
  customerId?: string;
  startTime: string;
  endTime: string;
  notes?: string;
}

interface ContactData {
  name: string;
  email?: string;
  phone?: string;
  customFields?: Record<string, any>;
}

// Integration types available
type IntegrationType = 
  | 'salesforce'
  | 'hubspot'
  | 'google_calendar'
  | 'outlook_calendar'
  | 'square'
  | 'fresha'
  | 'mindbody'
  | 'acuity'
  | 'calendly';
```

---

## 6.3 OAuth Manager

```typescript
// ============================================
// OAUTH MANAGER
// Handles OAuth 2.0 flows
// ============================================

class OAuthManager {
  constructor(private env: Env) {}

  async initiateFlow(
    workspaceId: string,
    integrationType: IntegrationType
  ): Promise<{ authUrl: string; state: string }> {
    
    // Generate state token for CSRF protection
    const state = crypto.randomUUID();

    // Store state in KV with expiration
    await this.env.KV.put(
      `oauth:state:${state}`,
      JSON.stringify({ workspaceId, integrationType }),
      { expirationTtl: 600 } // 10 minutes
    );

    // Get connector
    const connector = ConnectorFactory.create(integrationType, this.env);

    // Generate auth URL
    const redirectUri = `https://api.vocalized.app/integrations/oauth/callback/${integrationType}`;
    const authUrl = connector.getAuthUrl(state, redirectUri);

    return { authUrl, state };
  }

  async handleCallback(
    integrationType: IntegrationType,
    code: string,
    state: string
  ): Promise<{ workspaceId: string; integrationId: string }> {
    
    // Verify state
    const stateData = await this.env.KV.get(`oauth:state:${state}`);
    
    if (!stateData) {
      throw new Error('Invalid or expired state token');
    }

    const { workspaceId } = JSON.parse(stateData);

    // Delete state token
    await this.env.KV.delete(`oauth:state:${state}`);

    // Exchange code for tokens
    const connector = ConnectorFactory.create(integrationType, this.env);
    const redirectUri = `https://api.vocalized.app/integrations/oauth/callback/${integrationType}`;
    const tokens = await connector.exchangeCode(code, redirectUri);

    // Encrypt and store tokens
    const encryptedTokens = await this.encryptTokens(tokens);

    // Create integration record
    const integrationId = crypto.randomUUID();

    await this.env.DB
      .prepare(`
        INSERT INTO workspace_integrations
        (id, workspace_id, integration_type, name, status, auth_type, credentials_encrypted, created_at, updated_at)
        VALUES (?, ?, ?, ?, 'connected', 'oauth', ?, ?, ?)
      `)
      .bind(
        integrationId,
        workspaceId,
        integrationType,
        this.getIntegrationName(integrationType),
        encryptedTokens,
        Date.now(),
        Date.now()
      )
      .run();

    // Test connection
    try {
      const credentials = this.tokensToCredentials(tokens);
      await connector.testConnection(credentials);
    } catch (error) {
      // Update status to error
      await this.env.DB
        .prepare(`
          UPDATE workspace_integrations
          SET status = 'error'
          WHERE id = ?
        `)
        .bind(integrationId)
        .run();

      throw new Error(`Connection test failed: ${error.message}`);
    }

    // Trigger initial sync
    await this.triggerSync(integrationId);

    return { workspaceId, integrationId };
  }

  async refreshTokens(integrationId: string): Promise<void> {
    
    // Get integration
    const integration = await this.env.DB
      .prepare(`
        SELECT integration_type, credentials_encrypted
        FROM workspace_integrations
        WHERE id = ?
      `)
      .bind(integrationId)
      .first();

    if (!integration) {
      throw new Error('Integration not found');
    }

    // Decrypt tokens
    const tokens = await this.decryptTokens(integration.credentials_encrypted);

    if (!tokens.refreshToken) {
      throw new Error('No refresh token available');
    }

    // Refresh tokens
    const connector = ConnectorFactory.create(
      integration.integration_type as IntegrationType,
      this.env
    );

    const newTokens = await connector.refreshToken(tokens.refreshToken);

    // Encrypt and update
    const encryptedTokens = await this.encryptTokens(newTokens);

    await this.env.DB
      .prepare(`
        UPDATE workspace_integrations
        SET credentials_encrypted = ?, updated_at = ?
        WHERE id = ?
      `)
      .bind(encryptedTokens, Date.now(), integrationId)
      .run();
  }

  private async encryptTokens(tokens: OAuthTokens): Promise<string> {
    // Implement encryption
    // For now, using base64 encoding (NOT SECURE - implement proper encryption)
    const json = JSON.stringify(tokens);
    return btoa(json);
  }

  private async decryptTokens(encrypted: string): Promise<OAuthTokens> {
    // Implement decryption
    try {
      const json = atob(encrypted);
      return JSON.parse(json);
    } catch {
      throw new Error('Failed to decrypt tokens');
    }
  }

  private tokensToCredentials(tokens: OAuthTokens): IntegrationCredentials {
    return {
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt: tokens.expiresIn 
        ? Date.now() + (tokens.expiresIn * 1000)
        : undefined
    };
  }

  private getIntegrationName(type: IntegrationType): string {
    const names: Record<IntegrationType, string> = {
      salesforce: 'Salesforce',
      hubspot: 'HubSpot',
      google_calendar: 'Google Calendar',
      outlook_calendar: 'Outlook Calendar',
      square: 'Square',
      fresha: 'Fresha',
      mindbody: 'Mindbody',
      acuity: 'Acuity Scheduling',
      calendly: 'Calendly'
    };

    return names[type] || type;
  }

  private async triggerSync(integrationId: string): Promise<void> {
    // Queue initial sync job
    await this.env.SYNC_QUEUE.send({
      integrationId,
      syncType: 'full'
    });
  }
}
```

---

## 6.4 Integration Connectors

### Google Calendar Connector

```typescript
// ============================================
// GOOGLE CALENDAR CONNECTOR
// ============================================

class GoogleCalendarConnector implements IntegrationConnector {
  type = 'google_calendar';
  name = 'Google Calendar';

  constructor(private env: Env) {}

  getAuthUrl(state: string, redirectUri: string): string {
    const params = new URLSearchParams({
      client_id: this.env.GOOGLE_CLIENT_ID,
      redirect_uri: redirectUri,
      response_type: 'code',
      scope: 'https://www.googleapis.com/auth/calendar https://www.googleapis.com/auth/calendar.events',
      access_type: 'offline',
      prompt: 'consent',
      state
    });

    return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
  }

  async exchangeCode(code: string, redirectUri: string): Promise<OAuthTokens> {
    const response = await fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        code,
        client_id: this.env.GOOGLE_CLIENT_ID,
        client_secret: this.env.GOOGLE_CLIENT_SECRET,
        redirect_uri: redirectUri,
        grant_type: 'authorization_code'
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      tokenType: data.token_type,
      scope: data.scope
    };
  }

  async refreshToken(refreshToken: string): Promise<OAuthTokens> {
    const response = await fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        refresh_token: refreshToken,
        client_id: this.env.GOOGLE_CLIENT_ID,
        client_secret: this.env.GOOGLE_CLIENT_SECRET,
        grant_type: 'refresh_token'
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token refresh failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: refreshToken, // Reuse existing refresh token
      expiresIn: data.expires_in,
      tokenType: data.token_type
    };
  }

  async testConnection(credentials: IntegrationCredentials): Promise<boolean> {
    try {
      const response = await fetch(
        'https://www.googleapis.com/calendar/v3/users/me/calendarList',
        {
          headers: {
            'Authorization': `Bearer ${credentials.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  async syncData(
    credentials: IntegrationCredentials,
    config: SyncConfig
  ): Promise<SyncResult> {
    
    if (config.direction !== 'pull' && config.direction !== 'bidirectional') {
      return { success: true, recordsSynced: 0 };
    }

    try {
      // Get calendars
      const calendarsResponse = await fetch(
        'https://www.googleapis.com/calendar/v3/users/me/calendarList',
        {
          headers: {
            'Authorization': `Bearer ${credentials.accessToken}`
          }
        }
      );

      if (!calendarsResponse.ok) {
        throw new Error('Failed to fetch calendars');
      }

      const calendarsData = await calendarsResponse.json();
      let totalSynced = 0;

      // Sync events from each calendar
      for (const calendar of calendarsData.items) {
        const eventsResponse = await fetch(
          `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendar.id)}/events?timeMin=${new Date().toISOString()}`,
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (!eventsResponse.ok) continue;

        const eventsData = await eventsResponse.json();
        totalSynced += eventsData.items?.length || 0;
      }

      return {
        success: true,
        recordsSynced: totalSynced
      };

    } catch (error) {
      return {
        success: false,
        recordsSynced: 0,
        errors: [{ record: null, error: error.message }]
      };
    }
  }

  async createAppointment(
    credentials: IntegrationCredentials,
    data: AppointmentData
  ): Promise<any> {
    
    const event = {
      summary: data.notes || 'Appointment',
      start: {
        dateTime: data.startTime,
        timeZone: 'UTC'
      },
      end: {
        dateTime: data.endTime,
        timeZone: 'UTC'
      }
    };

    const response = await fetch(
      'https://www.googleapis.com/calendar/v3/calendars/primary/events',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(event)
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create event: ${error}`);
    }

    return await response.json();
  }

  async getAvailability(
    credentials: IntegrationCredentials,
    params: { start: string; end: string }
  ): Promise<any> {
    
    const response = await fetch(
      'https://www.googleapis.com/calendar/v3/freeBusy',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          timeMin: params.start,
          timeMax: params.end,
          items: [{ id: 'primary' }]
        })
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to get availability: ${error}`);
    }

    return await response.json();
  }
}
```

### Salesforce Connector

```typescript
// ============================================
// SALESFORCE CONNECTOR
// ============================================

class SalesforceConnector implements IntegrationConnector {
  type = 'salesforce';
  name = 'Salesforce';

  constructor(private env: Env) {}

  getAuthUrl(state: string, redirectUri: string): string {
    const params = new URLSearchParams({
      client_id: this.env.SALESFORCE_CLIENT_ID,
      redirect_uri: redirectUri,
      response_type: 'code',
      state
    });

    return `https://login.salesforce.com/services/oauth2/authorize?${params.toString()}`;
  }

  async exchangeCode(code: string, redirectUri: string): Promise<OAuthTokens> {
    const response = await fetch('https://login.salesforce.com/services/oauth2/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code,
        client_id: this.env.SALESFORCE_CLIENT_ID,
        client_secret: this.env.SALESFORCE_CLIENT_SECRET,
        redirect_uri: redirectUri
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      tokenType: data.token_type,
      scope: data.scope
    };
  }

  async refreshToken(refreshToken: string): Promise<OAuthTokens> {
    const response = await fetch('https://login.salesforce.com/services/oauth2/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: this.env.SALESFORCE_CLIENT_ID,
        client_secret: this.env.SALESFORCE_CLIENT_SECRET
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token refresh failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: refreshToken,
      tokenType: data.token_type
    };
  }

  async testConnection(credentials: IntegrationCredentials): Promise<boolean> {
    try {
      // Get instance URL from metadata
      const instanceUrl = credentials.metadata?.instanceUrl || 'https://login.salesforce.com';
      
      const response = await fetch(
        `${instanceUrl}/services/data/v58.0/sobjects/`,
        {
          headers: {
            'Authorization': `Bearer ${credentials.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  async syncData(
    credentials: IntegrationCredentials,
    config: SyncConfig
  ): Promise<SyncResult> {
    
    const instanceUrl = credentials.metadata?.instanceUrl || 'https://login.salesforce.com';
    let totalSynced = 0;
    const errors: Array<{ record: any; error: string }> = [];

    try {
      // Sync contacts
      if (config.resources.includes('contacts')) {
        const query = `SELECT Id, Name, Email, Phone FROM Contact WHERE LastModifiedDate > ${config.lastSyncAt || '2000-01-01T00:00:00Z'}`;
        
        const response = await fetch(
          `${instanceUrl}/services/data/v58.0/query?q=${encodeURIComponent(query)}`,
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.totalSize || 0;
        }
      }

      // Sync opportunities
      if (config.resources.includes('opportunities')) {
        const query = `SELECT Id, Name, StageName, Amount FROM Opportunity WHERE LastModifiedDate > ${config.lastSyncAt || '2000-01-01T00:00:00Z'}`;
        
        const response = await fetch(
          `${instanceUrl}/services/data/v58.0/query?q=${encodeURIComponent(query)}`,
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.totalSize || 0;
        }
      }

      return {
        success: true,
        recordsSynced: totalSynced,
        errors: errors.length > 0 ? errors : undefined
      };

    } catch (error) {
      return {
        success: false,
        recordsSynced: totalSynced,
        errors: [{ record: null, error: error.message }]
      };
    }
  }

  async lookupContact(
    credentials: IntegrationCredentials,
    identifier: string
  ): Promise<any> {
    
    const instanceUrl = credentials.metadata?.instanceUrl || 'https://login.salesforce.com';
    
    // Try to find contact by phone or email
    const query = `SELECT Id, Name, Email, Phone FROM Contact WHERE Phone = '${identifier}' OR Email = '${identifier}' LIMIT 1`;
    
    const response = await fetch(
      `${instanceUrl}/services/data/v58.0/query?q=${encodeURIComponent(query)}`,
      {
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`
        }
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Lookup failed: ${error}`);
    }

    const data = await response.json();
    return data.records?.[0] || null;
  }

  async createContact(
    credentials: IntegrationCredentials,
    data: ContactData
  ): Promise<any> {
    
    const instanceUrl = credentials.metadata?.instanceUrl || 'https://login.salesforce.com';
    
    const contact = {
      LastName: data.name,
      Email: data.email,
      Phone: data.phone,
      ...data.customFields
    };

    const response = await fetch(
      `${instanceUrl}/services/data/v58.0/sobjects/Contact`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(contact)
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create contact: ${error}`);
    }

    return await response.json();
  }
}
```

---

**Continue with Part 2 of Integration Hub (HubSpot, Square, Sync Engine)?**
#vocalized