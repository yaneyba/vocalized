---
tags:
  - vocalized
  - ai
  - gateway
  - voice-ai
  - pipeline
---
## WORKER IMPLEMENTATION - Part 2

## 4.6 Failover Manager

```typescript
// ============================================
// FAILOVER MANAGER
// ============================================

class FailoverManager {
  constructor(
    private env: Env,
    private maxRetries: number = 3
  ) {}

  async executeWithFailover<T>(
    workspaceId: string,
    operation: () => Promise<T>,
    primaryProvider: string,
    allProviders: ProviderConfig[],
    healthMap: Map<string, HealthStatus>
  ): Promise<T> {
    
    const attemptedProviders = new Set<string>([primaryProvider]);
    let lastError: Error | null = null;

    // Try primary provider first
    try {
      const result = await this.withTimeout(operation(), 30000); // 30s timeout
      
      // Success - update health if it was previously degraded
      await this.updateProviderHealth(primaryProvider, 'healthy');
      
      return result;
      
    } catch (error) {
      console.error(`Primary provider ${primaryProvider} failed:`, error);
      lastError = error;
      
      // Mark provider as degraded
      await this.updateProviderHealth(primaryProvider, 'degraded', error.message);
    }

    // Try failover providers
    const failoverCandidates = this.getFailoverCandidates(
      primaryProvider,
      allProviders,
      healthMap,
      attemptedProviders
    );

    for (const candidate of failoverCandidates) {
      try {
        console.log(`Failing over to ${candidate.provider}`);
        
        // Get API key for failover provider
        const apiKey = await this.getProviderApiKey(
          workspaceId,
          candidate.provider
        );
        
        // Create provider instance
        const provider = ProviderFactory.create(candidate.provider, apiKey);
        
        // Retry the operation with new provider
        // Note: This requires the operation to be re-creatable with new provider
        // In practice, you'd pass provider as param to operation
        const result = await this.withTimeout(operation(), 30000);
        
        // Success with failover
        await this.updateProviderHealth(candidate.provider, 'healthy');
        
        // Log successful failover
        await this.logFailover(
          workspaceId,
          primaryProvider,
          candidate.provider,
          'success'
        );
        
        return result;
        
      } catch (error) {
        console.error(`Failover to ${candidate.provider} failed:`, error);
        lastError = error;
        attemptedProviders.add(candidate.provider);
        
        await this.updateProviderHealth(
          candidate.provider,
          'degraded',
          error.message
        );
      }
    }

    // All providers failed
    await this.logFailover(
      workspaceId,
      primaryProvider,
      'none',
      'all_failed'
    );

    throw new NoProvidersAvailableError(
      `All providers failed. Last error: ${lastError?.message}`
    );
  }

  private getFailoverCandidates(
    failedProvider: string,
    allProviders: ProviderConfig[],
    healthMap: Map<string, HealthStatus>,
    attempted: Set<string>
  ): ProviderConfig[] {
    
    return allProviders
      .filter(p => {
        // Skip already attempted providers
        if (attempted.has(p.provider)) return false;
        
        // Must be enabled
        if (!p.is_enabled) return false;
        
        // Check health status
        const health = healthMap.get(p.provider);
        return health?.status === 'healthy' || health?.status === 'degraded';
      })
      .sort((a, b) => {
        // Sort by priority (higher first)
        return (b.priority || 0) - (a.priority || 0);
      });
  }

  private async getProviderApiKey(
    workspaceId: string,
    provider: string
  ): Promise<string> {
    
    // Check if workspace has custom key
    const workspaceConfig = await this.env.DB
      .prepare(`
        SELECT uses_platform_key, api_key_encrypted 
        FROM workspace_provider_configs 
        WHERE workspace_id = ? AND provider = ?
      `)
      .bind(workspaceId, provider)
      .first();

    if (workspaceConfig && !workspaceConfig.uses_platform_key) {
      // Use workspace's custom key
      return this.decryptApiKey(workspaceConfig.api_key_encrypted);
    }

    // Use platform key from KV or env
    const platformKey = await this.env.KV.get(`platform:${provider}:api_key`);
    
    if (platformKey) {
      return this.decryptApiKey(platformKey);
    }

    // Fallback to env variable
    const envKey = this.env[`${provider.toUpperCase()}_API_KEY`];
    if (envKey) return envKey;

    throw new Error(`No API key found for provider: ${provider}`);
  }

  private decryptApiKey(encrypted: string): string {
    // Implement decryption logic
    // For now, assuming it's base64 encoded
    try {
      return atob(encrypted);
    } catch {
      return encrypted; // Return as-is if not encrypted
    }
  }

  private async updateProviderHealth(
    provider: string,
    status: 'healthy' | 'degraded' | 'down',
    error?: string
  ): Promise<void> {
    
    // Update via Durable Object
    const healthId = this.env.PROVIDER_HEALTH_DO.idFromName('global-health-monitor');
    const healthStub = this.env.PROVIDER_HEALTH_DO.get(healthId);
    
    await healthStub.fetch('https://do/update', {
      method: 'POST',
      body: JSON.stringify({
        provider,
        status,
        error,
        timestamp: Date.now()
      })
    });
  }

  private async logFailover(
    workspaceId: string,
    fromProvider: string,
    toProvider: string,
    result: string
  ): Promise<void> {
    
    // Log to database for analytics
    await this.env.DB
      .prepare(`
        INSERT INTO failover_logs 
        (id, workspace_id, from_provider, to_provider, result, timestamp)
        VALUES (?, ?, ?, ?, ?, ?)
      `)
      .bind(
        crypto.randomUUID(),
        workspaceId,
        fromProvider,
        toProvider,
        result,
        Date.now()
      )
      .run()
      .catch(err => console.error('Failed to log failover:', err));
  }

  private withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<T>((_, reject) =>
        setTimeout(() => reject(new Error('Operation timeout')), ms)
      )
    ]);
  }
}

// Add failover_logs table to schema
/*
CREATE TABLE failover_logs (
    id TEXT PRIMARY KEY,
    workspace_id TEXT NOT NULL,
    from_provider TEXT NOT NULL,
    to_provider TEXT NOT NULL,
    result TEXT NOT NULL, -- success, all_failed
    timestamp INTEGER NOT NULL,
    FOREIGN KEY (workspace_id) REFERENCES workspaces(id) ON DELETE CASCADE
);

CREATE INDEX idx_failover_workspace ON failover_logs(workspace_id);
CREATE INDEX idx_failover_timestamp ON failover_logs(timestamp);
*/
```

---

## 4.7 Provider Health Monitor (Durable Object)

```typescript
// ============================================
// PROVIDER HEALTH MONITOR (DURABLE OBJECT)
// Maintains global health status for all providers
// ============================================

export class ProviderHealthMonitor {
  private state: DurableObjectState;
  private env: Env;
  private healthData: Map<string, HealthStatus>;
  private checkInterval: number = 60000; // 1 minute
  private intervalId?: number;

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
    this.healthData = new Map();
  }

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    // Initialize health data on first request
    if (this.healthData.size === 0) {
      await this.initialize();
    }

    // Start periodic health checks
    if (!this.intervalId) {
      this.startHealthChecks();
    }

    switch (path) {
      case '/health':
        return this.handleGetHealth(request);
      
      case '/update':
        return this.handleUpdateHealth(request);
      
      case '/check':
        return this.handleManualCheck(request);
      
      default:
        return new Response('Not found', { status: 404 });
    }
  }

  private async initialize(): Promise<void> {
    // Load health data from Durable Object storage
    const stored = await this.state.storage.get<Record<string, HealthStatus>>('health_data');
    
    if (stored) {
      this.healthData = new Map(Object.entries(stored));
    } else {
      // Initialize with default providers
      const providers = ['elevenlabs', 'deepgram', 'vapi', 'retell'];
      
      for (const provider of providers) {
        this.healthData.set(provider, {
          provider,
          status: 'healthy',
          lastCheck: Date.now()
        });
      }
      
      await this.persistHealthData();
    }
  }

  private async handleGetHealth(request: Request): Promise<Response> {
    const healthObject = Object.fromEntries(this.healthData);
    return Response.json(healthObject);
  }

  private async handleUpdateHealth(request: Request): Promise<Response> {
    const update = await request.json();
    const { provider, status, error, timestamp } = update;

    const current = this.healthData.get(provider) || {
      provider,
      status: 'healthy',
      lastCheck: Date.now()
    };

    // Update status
    current.status = status;
    current.lastCheck = timestamp || Date.now();
    
    if (error) {
      current.error = error;
    } else {
      delete current.error;
    }

    // Update error rate (simple moving average)
    if (status === 'degraded' || status === 'down') {
      current.errorRate = (current.errorRate || 0) * 0.9 + 0.1;
    } else {
      current.errorRate = (current.errorRate || 0) * 0.95;
    }

    this.healthData.set(provider, current);
    
    // Persist to storage
    await this.persistHealthData();

    // Also update database for long-term tracking
    await this.updateDatabase(current);

    return Response.json({ success: true });
  }

  private async handleManualCheck(request: Request): Promise<Response> {
    await this.performHealthChecks();
    return Response.json({ success: true, checks: this.healthData.size });
  }

  private startHealthChecks(): void {
    // Perform health checks periodically
    this.intervalId = setInterval(async () => {
      try {
        await this.performHealthChecks();
      } catch (error) {
        console.error('Health check failed:', error);
      }
    }, this.checkInterval) as any;
  }

  private async performHealthChecks(): Promise<void> {
    const providers = ['elevenlabs', 'deepgram', 'vapi', 'retell'];
    
    // Get API keys from platform config
    const apiKeys = await this.getApiKeys(providers);

    // Check each provider in parallel
    const checks = providers.map(async (providerName) => {
      const apiKey = apiKeys.get(providerName);
      if (!apiKey) return;

      try {
        const provider = ProviderFactory.create(providerName, apiKey);
        const health = await provider.healthCheck();
        
        // Update health data
        this.healthData.set(providerName, health);
        
      } catch (error) {
        // Provider check failed
        this.healthData.set(providerName, {
          provider: providerName,
          status: 'down',
          error: error.message,
          lastCheck: Date.now()
        });
      }
    });

    await Promise.allSettled(checks);
    
    // Persist updates
    await this.persistHealthData();
    
    // Update database
    for (const [_, health] of this.healthData) {
      await this.updateDatabase(health);
    }
  }

  private async getApiKeys(providers: string[]): Promise<Map<string, string>> {
    const keys = new Map<string, string>();

    for (const provider of providers) {
      // Try KV first
      const kvKey = await this.env.KV.get(`platform:${provider}:api_key`);
      
      if (kvKey) {
        keys.set(provider, this.decryptApiKey(kvKey));
        continue;
      }

      // Fallback to env variable
      const envKey = this.env[`${provider.toUpperCase()}_API_KEY`];
      if (envKey) {
        keys.set(provider, envKey);
      }
    }

    return keys;
  }

  private decryptApiKey(encrypted: string): string {
    // Implement decryption
    try {
      return atob(encrypted);
    } catch {
      return encrypted;
    }
  }

  private async persistHealthData(): Promise<void> {
    const healthObject = Object.fromEntries(this.healthData);
    await this.state.storage.put('health_data', healthObject);
  }

  private async updateDatabase(health: HealthStatus): Promise<void> {
    try {
      await this.env.DB
        .prepare(`
          INSERT OR REPLACE INTO provider_health_status 
          (provider, region, status, last_check, error_rate, avg_latency, details)
          VALUES (?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          health.provider,
          'global', // Could be region-specific
          health.status,
          health.lastCheck,
          health.errorRate || 0,
          health.latency || null,
          JSON.stringify({ error: health.error })
        )
        .run();
    } catch (error) {
      console.error('Failed to update database:', error);
    }
  }
}
```

---

## 4.8 Main Voice Gateway Class

```typescript
// ============================================
// VOICE GATEWAY - Main Orchestrator
// ============================================

class VoiceGateway {
  private failoverManager: FailoverManager;

  constructor(private env: Env) {
    this.failoverManager = new FailoverManager(env);
  }

  // ==========================================
  // SYNTHESIZE (Text-to-Speech)
  // ==========================================
  
  async synthesize(request: GatewayRequest): Promise<SynthesisResponse> {
    const { workspaceId, text, voiceConfig } = request;

    if (!text) {
      throw new Error('Text is required for synthesis');
    }

    // 1. Get workspace provider configurations
    const providers = await this.getWorkspaceProviders(workspaceId);

    if (providers.length === 0) {
      throw new Error('No providers configured for workspace');
    }

    // 2. Get provider health status
    const healthMap = await this.getProviderHealth();

    // 3. Get selection strategy
    const strategy = await this.getSelectionStrategy(workspaceId);

    // 4. Select primary provider
    const selectedProvider = strategy.selectProvider(
      providers,
      healthMap,
      request
    );

    if (!selectedProvider) {
      throw new NoProvidersAvailableError();
    }

    // 5. Get API key
    const apiKey = await this.getProviderApiKey(
      workspaceId,
      selectedProvider.provider
    );

    // 6. Create provider instance
    const provider = ProviderFactory.create(
      selectedProvider.provider,
      apiKey
    );

    // 7. Execute with failover
    const response = await this.failoverManager.executeWithFailover(
      workspaceId,
      () => provider.synthesize(text, voiceConfig || {}),
      selectedProvider.provider,
      providers,
      healthMap
    );

    // 8. Track usage for billing
    await this.trackUsage(workspaceId, {
      resourceType: 'synthesis',
      provider: response.provider,
      quantity: response.characters || text.length,
      cost: response.cost
    });

    return response;
  }

  // ==========================================
  // TRANSCRIBE (Speech-to-Text)
  // ==========================================
  
  async transcribe(request: GatewayRequest): Promise<TranscriptionResponse> {
    const { workspaceId, audio, transcribeConfig } = request;

    if (!audio) {
      throw new Error('Audio is required for transcription');
    }

    // Similar flow to synthesize
    const providers = await this.getWorkspaceProviders(workspaceId);
    const healthMap = await this.getProviderHealth();
    const strategy = await this.getSelectionStrategy(workspaceId);

    const selectedProvider = strategy.selectProvider(
      providers,
      healthMap,
      request
    );

    if (!selectedProvider) {
      throw new NoProvidersAvailableError();
    }

    const apiKey = await this.getProviderApiKey(
      workspaceId,
      selectedProvider.provider
    );

    const provider = ProviderFactory.create(
      selectedProvider.provider,
      apiKey
    );

    const response = await this.failoverManager.executeWithFailover(
      workspaceId,
      () => provider.transcribe(audio, transcribeConfig || {}),
      selectedProvider.provider,
      providers,
      healthMap
    );

    // Track usage
    await this.trackUsage(workspaceId, {
      resourceType: 'transcription',
      provider: response.provider,
      quantity: audio.byteLength,
      cost: response.cost
    });

    return response;
  }

  // ==========================================
  // STREAM SYNTHESIS
  // ==========================================
  
  async streamSynthesize(request: GatewayRequest): Promise<ReadableStream> {
    const { workspaceId, text, voiceConfig } = request;

    if (!text) {
      throw new Error('Text is required for streaming synthesis');
    }

    const providers = await this.getWorkspaceProviders(workspaceId);
    const healthMap = await this.getProviderHealth();
    const strategy = await this.getSelectionStrategy(workspaceId);

    const selectedProvider = strategy.selectProvider(
      providers,
      healthMap,
      request
    );

    if (!selectedProvider) {
      throw new NoProvidersAvailableError();
    }

    const apiKey = await this.getProviderApiKey(
      workspaceId,
      selectedProvider.provider
    );

    const provider = ProviderFactory.create(
      selectedProvider.provider,
      apiKey
    );

    try {
      const stream = provider.streamSynthesize(text, voiceConfig || {});
      
      // Track usage (estimated)
      const estimatedCost = provider.estimateCost('synthesis', text.length);
      await this.trackUsage(workspaceId, {
        resourceType: 'synthesis_stream',
        provider: selectedProvider.provider,
        quantity: text.length,
        cost: estimatedCost
      });

      return stream;
      
    } catch (error) {
      // Fallback to non-streaming if streaming fails
      console.warn('Streaming failed, falling back to regular synthesis');
      
      const response = await this.synthesize(request);
      
      // Convert audio buffer to stream
      return new ReadableStream({
        start(controller) {
          if (response.audio) {
            controller.enqueue(new Uint8Array(response.audio));
          }
          controller.close();
        }
      });
    }
  }

  // ==========================================
  // HELPER METHODS
  // ==========================================

  private async getWorkspaceProviders(
    workspaceId: string
  ): Promise<ProviderConfig[]> {
    
    // Get workspace-specific configs
    const workspaceConfigs = await this.env.DB
      .prepare(`
        SELECT provider, is_enabled, config
        FROM workspace_provider_configs
        WHERE workspace_id = ? AND is_enabled = 1
      `)
      .bind(workspaceId)
      .all();

    if (workspaceConfigs.results.length > 0) {
      return workspaceConfigs.results.map(r => ({
        provider: r.provider,
        is_enabled: r.is_enabled === 1,
        priority: 0,
        config: r.config ? JSON.parse(r.config) : {}
      }));
    }

    // Fallback to platform providers
    const platformConfigs = await this.env.DB
      .prepare(`
        SELECT provider, is_enabled, priority, config
        FROM platform_provider_configs
        WHERE is_enabled = 1
        ORDER BY priority DESC
      `)
      .all();

    return platformConfigs.results.map(r => ({
      provider: r.provider,
      is_enabled: r.is_enabled === 1,
      priority: r.priority || 0,
      config: r.config ? JSON.parse(r.config) : {}
    }));
  }

  private async getProviderHealth(): Promise<Map<string, HealthStatus>> {
    // Get health from Durable Object
    const healthId = this.env.PROVIDER_HEALTH_DO.idFromName('global-health-monitor');
    const healthStub = this.env.PROVIDER_HEALTH_DO.get(healthId);
    
    const response = await healthStub.fetch('https://do/health');
    const data = await response.json();
    
    return new Map(Object.entries(data));
  }

  private async getSelectionStrategy(
    workspaceId: string
  ): Promise<SelectionStrategy> {
    
    const strategyConfig = await this.env.DB
      .prepare(`
        SELECT strategy, config
        FROM workspace_provider_strategies
        WHERE workspace_id = ?
      `)
      .bind(workspaceId)
      .first();

    if (!strategyConfig) {
      return new CostOptimizedStrategy(); // Default
    }

    const config = strategyConfig.config 
      ? JSON.parse(strategyConfig.config) 
      : {};

    return StrategyFactory.create(strategyConfig.strategy, config);
  }

  private async getProviderApiKey(
    workspaceId: string,
    provider: string
  ): Promise<string> {
    
    // Check workspace config
    const workspaceConfig = await this.env.DB
      .prepare(`
        SELECT uses_platform_key, api_key_encrypted
        FROM workspace_provider_configs
        WHERE workspace_id = ? AND provider = ?
      `)
      .bind(workspaceId, provider)
      .first();

    if (workspaceConfig && !workspaceConfig.uses_platform_key) {
      return this.decryptApiKey(workspaceConfig.api_key_encrypted);
    }

    // Use platform key
    const platformKey = await this.env.KV.get(`platform:${provider}:api_key`);
    
    if (platformKey) {
      return this.decryptApiKey(platformKey);
    }

    // Fallback to env
    const envKey = this.env[`${provider.toUpperCase()}_API_KEY`];
    if (envKey) return envKey;

    throw new Error(`No API key found for provider: ${provider}`);
  }

  private decryptApiKey(encrypted: string): string {
    try {
      return atob(encrypted);
    } catch {
      return encrypted;
    }
  }

  private async trackUsage(
    workspaceId: string,
    usage: {
      resourceType: string;
      provider: string;
      quantity: number;
      cost: number;
    }
  ): Promise<void> {
    
    // Get markup percentage from platform settings
    const markup = await this.getMarkupPercentage();
    const finalCost = usage.cost * (1 + markup / 100);

    // Get current billing period
    const billingPeriod = await this.getCurrentBillingPeriod(workspaceId);

    try {
      await this.env.DB
        .prepare(`
          INSERT INTO usage_records
          (id, workspace_id, resource_type, provider, quantity, unit_cost, total_cost, markup_percentage, final_cost, billing_period_id, created_at)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `)
        .bind(
          crypto.randomUUID(),
          workspaceId,
          usage.resourceType,
          usage.provider,
          usage.quantity,
          usage.cost / usage.quantity, // unit cost
          usage.cost,
          markup,
          finalCost,
          billingPeriod,
          Date.now()
        )
        .run();
    } catch (error) {
      console.error('Failed to track usage:', error);
      // Don't fail the request if usage tracking fails
    }
  }

  private async getMarkupPercentage(): Promise<number> {
    const setting = await this.env.DB
      .prepare(`SELECT value FROM platform_settings WHERE key = ?`)
      .bind('pricing_markup_percentage')
      .first();

    return setting ? parseFloat(setting.value) : 20; // Default 20%
  }

  private async getCurrentBillingPeriod(
    workspaceId: string
  ): Promise<string> {
    
    const period = await this.env.DB
      .prepare(`
        SELECT id
        FROM billing_periods
        WHERE workspace_id = ? AND status = 'current'
      `)
      .bind(workspaceId)
      .first();

    if (period) {
      return period.id;
    }

    // Create new billing period
    const now = Date.now();
    const periodStart = new Date();
    periodStart.setDate(1); // First day of month
    periodStart.setHours(0, 0, 0, 0);

    const periodEnd = new Date(periodStart);
    periodEnd.setMonth(periodEnd.getMonth() + 1);
    periodEnd.setDate(0); // Last day of month
    periodEnd.setHours(23, 59, 59, 999);

    const newPeriodId = crypto.randomUUID();

    await this.env.DB
      .prepare(`
        INSERT INTO billing_periods
        (id, workspace_id, period_start, period_end, status, created_at)
        VALUES (?, ?, ?, ?, 'current', ?)
      `)
      .bind(
        newPeriodId,
        workspaceId,
        periodStart.getTime(),
        periodEnd.getTime(),
        now
      )
      .run();

    return newPeriodId;
  }
}
```

---

## 4.9 Gateway Worker Entry Point

```typescript
// ============================================
// VOICE AI GATEWAY WORKER
// Main entry point
// ============================================

export { ProviderHealthMonitor as ProviderHealthDO };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    // CORS headers
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // Initialize gateway
      const gateway = new VoiceGateway(env);

      // Route requests
      if (path === '/voice/synthesize' && request.method === 'POST') {
        return await handleSynthesize(request, gateway, corsHeaders);
      }

      if (path === '/voice/transcribe' && request.method === 'POST') {
        return await handleTranscribe(request, gateway, corsHeaders);
      }

      if (path === '/voice/stream' && request.method === 'POST') {
        return await handleStream(request, gateway, corsHeaders);
      }

      if (path === '/voice/providers/health' && request.method === 'GET') {
        return await handleProviderHealth(env, corsHeaders);
      }

      return new Response('Not found', {
        status: 404,
        headers: corsHeaders
      });

    } catch (error) {
      console.error('Gateway error:', error);

      return Response.json(
        {
          error: error.message,
          type: error.name
        },
        {
          status: error instanceof NoProvidersAvailableError ? 503 : 500,
          headers: corsHeaders
        }
      );
    }
  }
};

// ==========================================
// REQUEST HANDLERS
// ==========================================

async function handleSynthesize(
  request: Request,
  gateway: VoiceGateway,
  corsHeaders: Record<string, string>
): Promise<Response> {
  
  const body = await request.json();

  const gatewayRequest: GatewayRequest = {
    workspaceId: body.workspaceId,
    operation: 'synthesize',
    text: body.text,
    voiceConfig: body.voiceConfig
  };

  const response = await gateway.synthesize(gatewayRequest);

  if (response.audio) {
    return new Response(response.audio, {
      headers: {
        ...corsHeaders,
        'Content-Type': response.contentType,
        'X-Provider': response.provider,
        'X-Cost': response.cost.toString(),
        'X-Characters': (response.characters || 0).toString()
      }
    });
  }

  // For providers like Vapi that return metadata
  return Response.json(
    {
      provider: response.provider,
      cost: response.cost,
      metadata: response.metadata
    },
    { headers: corsHeaders }
  );
}

async function handleTranscribe(
  request: Request,
  gateway: VoiceGateway,
  corsHeaders: Record<string, string>
): Promise<Response> {
  
  const body = await request.arrayBuffer();
  const url = new URL(request.url);
  const workspaceId = url.searchParams.get('workspaceId');

  if (!workspaceId) {
    return Response.json(
      { error: 'workspaceId required' },
      { status: 400, headers: corsHeaders }
    );
  }

  const gatewayRequest: GatewayRequest = {
    workspaceId,
    operation: 'transcribe',
    audio: body,
    transcribeConfig: {
      language: url.searchParams.get('language') || undefined,
      punctuate: url.searchParams.get('punctuate') === 'true',
      diarize: url.searchParams.get('diarize') === 'true'
    }
  };

  const response = await gateway.transcribe(gatewayRequest);

  return Response.json(
    {
      text: response.text,
      words: response.words,
      confidence: response.confidence,
      provider: response.provider,
      cost: response.cost
    },
    { headers: corsHeaders }
  );
}

async function handleStream(
  request: Request,
  gateway: VoiceGateway,
  corsHeaders: Record<string, string>
): Promise<Response> {
  
  const body = await request.json();

  const gatewayRequest: GatewayRequest = {
    workspaceId: body.workspaceId,
    operation: 'stream',
    text: body.text,
    voiceConfig: body.voiceConfig
  };

  const stream = await gateway.streamSynthesize(gatewayRequest);

  return new Response(stream, {
    headers: {
      ...corsHeaders,
      'Content-Type': 'audio/mpeg',
      'Transfer-Encoding': 'chunked'
    }
  });
}

async function handleProviderHealth(
  env: Env,
  corsHeaders: Record<string, string>
): Promise<Response> {
  
  // Get health from Durable Object
  const healthId = env.PROVIDER_HEALTH_DO.idFromName('global-health-monitor');
  const healthStub = env.PROVIDER_HEALTH_DO.get(healthId);
  
  const response = await healthStub.fetch('https://do/health');
  const health = await response.json();

  return Response.json(health, { headers: corsHeaders });
}
```

---

**This completes the Voice AI Gateway implementation. Ready for the next section?**
#vocalized