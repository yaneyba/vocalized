---
tags:
  - pipeline
  - vocalized
  - integration-hub
---
## 6.5 More Integration Connectors

### HubSpot Connector

```typescript
// ============================================
// HUBSPOT CONNECTOR
// ============================================

class HubSpotConnector implements IntegrationConnector {
  type = 'hubspot';
  name = 'HubSpot';

  constructor(private env: Env) {}

  getAuthUrl(state: string, redirectUri: string): string {
    const params = new URLSearchParams({
      client_id: this.env.HUBSPOT_CLIENT_ID,
      redirect_uri: redirectUri,
      scope: 'contacts crm.objects.contacts.read crm.objects.contacts.write',
      state
    });

    return `https://app.hubspot.com/oauth/authorize?${params.toString()}`;
  }

  async exchangeCode(code: string, redirectUri: string): Promise<OAuthTokens> {
    const response = await fetch('https://api.hubapi.com/oauth/v1/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code,
        client_id: this.env.HUBSPOT_CLIENT_ID,
        client_secret: this.env.HUBSPOT_CLIENT_SECRET,
        redirect_uri: redirectUri
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      tokenType: 'Bearer'
    };
  }

  async refreshToken(refreshToken: string): Promise<OAuthTokens> {
    const response = await fetch('https://api.hubapi.com/oauth/v1/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: this.env.HUBSPOT_CLIENT_ID,
        client_secret: this.env.HUBSPOT_CLIENT_SECRET
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token refresh failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      tokenType: 'Bearer'
    };
  }

  async testConnection(credentials: IntegrationCredentials): Promise<boolean> {
    try {
      const response = await fetch(
        'https://api.hubapi.com/crm/v3/objects/contacts?limit=1',
        {
          headers: {
            'Authorization': `Bearer ${credentials.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  async syncData(
    credentials: IntegrationCredentials,
    config: SyncConfig
  ): Promise<SyncResult> {
    
    let totalSynced = 0;
    const errors: Array<{ record: any; error: string }> = [];

    try {
      // Sync contacts
      if (config.resources.includes('contacts')) {
        const after = config.lastSyncAt 
          ? `&filterGroups[0][filters][0][propertyName]=lastmodifieddate&filterGroups[0][filters][0][operator]=GTE&filterGroups[0][filters][0][value]=${config.lastSyncAt}`
          : '';

        const response = await fetch(
          `https://api.hubapi.com/crm/v3/objects/contacts?limit=100${after}`,
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.results?.length || 0;
        }
      }

      // Sync deals
      if (config.resources.includes('deals')) {
        const after = config.lastSyncAt 
          ? `&filterGroups[0][filters][0][propertyName]=hs_lastmodifieddate&filterGroups[0][filters][0][operator]=GTE&filterGroups[0][filters][0][value]=${config.lastSyncAt}`
          : '';

        const response = await fetch(
          `https://api.hubapi.com/crm/v3/objects/deals?limit=100${after}`,
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.results?.length || 0;
        }
      }

      return {
        success: true,
        recordsSynced: totalSynced,
        errors: errors.length > 0 ? errors : undefined
      };

    } catch (error) {
      return {
        success: false,
        recordsSynced: totalSynced,
        errors: [{ record: null, error: error.message }]
      };
    }
  }

  async lookupContact(
    credentials: IntegrationCredentials,
    identifier: string
  ): Promise<any> {
    
    // Try email search first
    let response = await fetch(
      `https://api.hubapi.com/crm/v3/objects/contacts/search`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          filterGroups: [{
            filters: [{
              propertyName: 'email',
              operator: 'EQ',
              value: identifier
            }]
          }],
          limit: 1
        })
      }
    );

    if (response.ok) {
      const data = await response.json();
      if (data.results?.length > 0) {
        return data.results[0];
      }
    }

    // Try phone search
    response = await fetch(
      `https://api.hubapi.com/crm/v3/objects/contacts/search`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          filterGroups: [{
            filters: [{
              propertyName: 'phone',
              operator: 'EQ',
              value: identifier
            }]
          }],
          limit: 1
        })
      }
    );

    if (response.ok) {
      const data = await response.json();
      return data.results?.[0] || null;
    }

    return null;
  }

  async createContact(
    credentials: IntegrationCredentials,
    data: ContactData
  ): Promise<any> {
    
    const properties = {
      firstname: data.name.split(' ')[0],
      lastname: data.name.split(' ').slice(1).join(' ') || data.name.split(' ')[0],
      email: data.email,
      phone: data.phone,
      ...data.customFields
    };

    const response = await fetch(
      'https://api.hubapi.com/crm/v3/objects/contacts',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ properties })
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create contact: ${error}`);
    }

    return await response.json();
  }
}
```

---

### Square Connector

```typescript
// ============================================
// SQUARE CONNECTOR
// ============================================

class SquareConnector implements IntegrationConnector {
  type = 'square';
  name = 'Square';

  constructor(private env: Env) {}

  getAuthUrl(state: string, redirectUri: string): string {
    const params = new URLSearchParams({
      client_id: this.env.SQUARE_APPLICATION_ID,
      scope: 'APPOINTMENTS_READ APPOINTMENTS_WRITE CUSTOMERS_READ CUSTOMERS_WRITE',
      session: 'false',
      state
    });

    return `https://connect.squareup.com/oauth2/authorize?${params.toString()}`;
  }

  async exchangeCode(code: string, redirectUri: string): Promise<OAuthTokens> {
    const response = await fetch('https://connect.squareup.com/oauth2/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Square-Version': '2024-01-18'
      },
      body: JSON.stringify({
        client_id: this.env.SQUARE_APPLICATION_ID,
        client_secret: this.env.SQUARE_APPLICATION_SECRET,
        code,
        grant_type: 'authorization_code'
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_at 
        ? Math.floor((new Date(data.expires_at).getTime() - Date.now()) / 1000)
        : undefined,
      tokenType: 'Bearer'
    };
  }

  async refreshToken(refreshToken: string): Promise<OAuthTokens> {
    const response = await fetch('https://connect.squareup.com/oauth2/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Square-Version': '2024-01-18'
      },
      body: JSON.stringify({
        client_id: this.env.SQUARE_APPLICATION_ID,
        client_secret: this.env.SQUARE_APPLICATION_SECRET,
        refresh_token: refreshToken,
        grant_type: 'refresh_token'
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token refresh failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_at 
        ? Math.floor((new Date(data.expires_at).getTime() - Date.now()) / 1000)
        : undefined,
      tokenType: 'Bearer'
    };
  }

  async testConnection(credentials: IntegrationCredentials): Promise<boolean> {
    try {
      const response = await fetch(
        'https://connect.squareup.com/v2/locations',
        {
          headers: {
            'Authorization': `Bearer ${credentials.accessToken}`,
            'Square-Version': '2024-01-18'
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  async syncData(
    credentials: IntegrationCredentials,
    config: SyncConfig
  ): Promise<SyncResult> {
    
    let totalSynced = 0;
    const errors: Array<{ record: any; error: string }> = [];

    try {
      // Sync customers
      if (config.resources.includes('customers')) {
        const response = await fetch(
          'https://connect.squareup.com/v2/customers?limit=100',
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`,
              'Square-Version': '2024-01-18'
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.customers?.length || 0;
        }
      }

      // Sync bookings
      if (config.resources.includes('appointments')) {
        const startAt = config.lastSyncAt 
          ? new Date(config.lastSyncAt).toISOString()
          : new Date().toISOString();

        const response = await fetch(
          'https://connect.squareup.com/v2/bookings',
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`,
              'Content-Type': 'application/json',
              'Square-Version': '2024-01-18'
            },
            body: JSON.stringify({
              limit: 100,
              start_at_min: startAt
            })
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.bookings?.length || 0;
        }
      }

      return {
        success: true,
        recordsSynced: totalSynced,
        errors: errors.length > 0 ? errors : undefined
      };

    } catch (error) {
      return {
        success: false,
        recordsSynced: totalSynced,
        errors: [{ record: null, error: error.message }]
      };
    }
  }

  async createAppointment(
    credentials: IntegrationCredentials,
    data: AppointmentData
  ): Promise<any> {
    
    // Get location ID (first location)
    const locationsResponse = await fetch(
      'https://connect.squareup.com/v2/locations',
      {
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Square-Version': '2024-01-18'
        }
      }
    );

    if (!locationsResponse.ok) {
      throw new Error('Failed to get locations');
    }

    const locationsData = await locationsResponse.json();
    const locationId = locationsData.locations?.[0]?.id;

    if (!locationId) {
      throw new Error('No locations found');
    }

    // Create booking
    const booking = {
      idempotency_key: crypto.randomUUID(),
      booking: {
        location_id: locationId,
        start_at: data.startTime,
        customer_id: data.customerId,
        customer_note: data.notes
      }
    };

    const response = await fetch(
      'https://connect.squareup.com/v2/bookings',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json',
          'Square-Version': '2024-01-18'
        },
        body: JSON.stringify(booking)
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create booking: ${error}`);
    }

    return await response.json();
  }

  async lookupContact(
    credentials: IntegrationCredentials,
    identifier: string
  ): Promise<any> {
    
    // Search by phone or email
    const response = await fetch(
      'https://connect.squareup.com/v2/customers/search',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json',
          'Square-Version': '2024-01-18'
        },
        body: JSON.stringify({
          query: {
            filter: {
              phone_number: {
                exact: identifier
              }
            }
          },
          limit: 1
        })
      }
    );

    if (response.ok) {
      const data = await response.json();
      if (data.customers?.length > 0) {
        return data.customers[0];
      }
    }

    // Try email search
    const emailResponse = await fetch(
      'https://connect.squareup.com/v2/customers/search',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json',
          'Square-Version': '2024-01-18'
        },
        body: JSON.stringify({
          query: {
            filter: {
              email_address: {
                exact: identifier
              }
            }
          },
          limit: 1
        })
      }
    );

    if (emailResponse.ok) {
      const data = await emailResponse.json();
      return data.customers?.[0] || null;
    }

    return null;
  }

  async createContact(
    credentials: IntegrationCredentials,
    data: ContactData
  ): Promise<any> {
    
    const customer = {
      idempotency_key: crypto.randomUUID(),
      given_name: data.name.split(' ')[0],
      family_name: data.name.split(' ').slice(1).join(' '),
      email_address: data.email,
      phone_number: data.phone
    };

    const response = await fetch(
      'https://connect.squareup.com/v2/customers',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json',
          'Square-Version': '2024-01-18'
        },
        body: JSON.stringify(customer)
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create customer: ${error}`);
    }

    return await response.json();
  }

  async getAvailability(
    credentials: IntegrationCredentials,
    params: { start: string; end: string; serviceId?: string }
  ): Promise<any> {
    
    // Get location
    const locationsResponse = await fetch(
      'https://connect.squareup.com/v2/locations',
      {
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Square-Version': '2024-01-18'
        }
      }
    );

    if (!locationsResponse.ok) {
      throw new Error('Failed to get locations');
    }

    const locationsData = await locationsResponse.json();
    const locationId = locationsData.locations?.[0]?.id;

    // Search availability
    const response = await fetch(
      'https://connect.squareup.com/v2/bookings/availability/search',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json',
          'Square-Version': '2024-01-18'
        },
        body: JSON.stringify({
          query: {
            filter: {
              location_id: locationId,
              start_at_range: {
                start_at: params.start,
                end_at: params.end
              }
            }
          }
        })
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to get availability: ${error}`);
    }

    return await response.json();
  }
}
```

---

### Fresha Connector

```typescript
// ============================================
// FRESHA CONNECTOR
// ============================================

class FreshaConnector implements IntegrationConnector {
  type = 'fresha';
  name = 'Fresha';

  constructor(private env: Env) {}

  getAuthUrl(state: string, redirectUri: string): string {
    const params = new URLSearchParams({
      client_id: this.env.FRESHA_CLIENT_ID,
      redirect_uri: redirectUri,
      response_type: 'code',
      scope: 'appointments:read appointments:write customers:read customers:write',
      state
    });

    return `https://connect.fresha.com/oauth/authorize?${params.toString()}`;
  }

  async exchangeCode(code: string, redirectUri: string): Promise<OAuthTokens> {
    const response = await fetch('https://api.fresha.com/oauth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'authorization_code',
        code,
        client_id: this.env.FRESHA_CLIENT_ID,
        client_secret: this.env.FRESHA_CLIENT_SECRET,
        redirect_uri: redirectUri
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      tokenType: 'Bearer'
    };
  }

  async refreshToken(refreshToken: string): Promise<OAuthTokens> {
    const response = await fetch('https://api.fresha.com/oauth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: this.env.FRESHA_CLIENT_ID,
        client_secret: this.env.FRESHA_CLIENT_SECRET
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token refresh failed: ${error}`);
    }

    const data = await response.json();

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in,
      tokenType: 'Bearer'
    };
  }

  async testConnection(credentials: IntegrationCredentials): Promise<boolean> {
    try {
      const response = await fetch(
        'https://api.fresha.com/v2/business/locations',
        {
          headers: {
            'Authorization': `Bearer ${credentials.accessToken}`
          }
        }
      );

      return response.ok;
    } catch {
      return false;
    }
  }

  async syncData(
    credentials: IntegrationCredentials,
    config: SyncConfig
  ): Promise<SyncResult> {
    
    let totalSynced = 0;
    const errors: Array<{ record: any; error: string }> = [];

    try {
      // Sync clients
      if (config.resources.includes('clients')) {
        const response = await fetch(
          'https://api.fresha.com/v2/business/clients?limit=100',
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.data?.length || 0;
        }
      }

      // Sync appointments
      if (config.resources.includes('appointments')) {
        const from = config.lastSyncAt 
          ? new Date(config.lastSyncAt).toISOString()
          : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();

        const response = await fetch(
          `https://api.fresha.com/v2/business/appointments?from=${from}&limit=100`,
          {
            headers: {
              'Authorization': `Bearer ${credentials.accessToken}`
            }
          }
        );

        if (response.ok) {
          const data = await response.json();
          totalSynced += data.data?.length || 0;
        }
      }

      return {
        success: true,
        recordsSynced: totalSynced,
        errors: errors.length > 0 ? errors : undefined
      };

    } catch (error) {
      return {
        success: false,
        recordsSynced: totalSynced,
        errors: [{ record: null, error: error.message }]
      };
    }
  }

  async createAppointment(
    credentials: IntegrationCredentials,
    data: AppointmentData
  ): Promise<any> {
    
    const appointment = {
      client_id: data.customerId,
      service_id: data.serviceId,
      staff_id: data.staffId,
      start_time: data.startTime,
      notes: data.notes
    };

    const response = await fetch(
      'https://api.fresha.com/v2/business/appointments',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(appointment)
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create appointment: ${error}`);
    }

    return await response.json();
  }

  async lookupContact(
    credentials: IntegrationCredentials,
    identifier: string
  ): Promise<any> {
    
    // Search by phone or email
    const response = await fetch(
      `https://api.fresha.com/v2/business/clients?search=${encodeURIComponent(identifier)}`,
      {
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`
        }
      }
    );

    if (response.ok) {
      const data = await response.json();
      return data.data?.[0] || null;
    }

    return null;
  }

  async createContact(
    credentials: IntegrationCredentials,
    data: ContactData
  ): Promise<any> {
    
    const client = {
      first_name: data.name.split(' ')[0],
      last_name: data.name.split(' ').slice(1).join(' '),
      email: data.email,
      phone: data.phone
    };

    const response = await fetch(
      'https://api.fresha.com/v2/business/clients',
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(client)
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create client: ${error}`);
    }

    return await response.json();
  }

  async getAvailability(
    credentials: IntegrationCredentials,
    params: { start: string; end: string; serviceId?: string }
  ): Promise<any> {
    
    const queryParams = new URLSearchParams({
      from: params.start,
      to: params.end
    });

    if (params.serviceId) {
      queryParams.append('service_id', params.serviceId);
    }

    const response = await fetch(
      `https://api.fresha.com/v2/business/availability?${queryParams.toString()}`,
      {
        headers: {
          'Authorization': `Bearer ${credentials.accessToken}`
        }
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to get availability: ${error}`);
    }

    return await response.json();
  }
}
```

---

## 6.6 Connector Factory

```typescript
// ============================================
// CONNECTOR FACTORY
// ============================================

class ConnectorFactory {
  static create(
    type: IntegrationType,
    env: Env
  ): IntegrationConnector {
    
    switch (type) {
      case 'google_calendar':
        return new GoogleCalendarConnector(env);
      
      case 'salesforce':
        return new SalesforceConnector(env);
      
      case 'hubspot':
        return new HubSpotConnector(env);
      
      case 'square':
        return new SquareConnector(env);
      
      case 'fresha':
        return new FreshaConnector(env);
      
      // Add more connectors here
      
      default:
        throw new Error(`Unsupported integration type: ${type}`);
    }
  }

  static getSupportedTypes(): IntegrationType[] {
    return [
      'google_calendar',
      'salesforce',
      'hubspot',
      'square',
      'fresha'
    ];
  }

  static getIntegrationInfo(type: IntegrationType): {
    name: string;
    description: string;
    capabilities: string[];
  } {
    
    const info: Record<IntegrationType, any> = {
      google_calendar: {
        name: 'Google Calendar',
        description: 'Sync appointments with Google Calendar',
        capabilities: ['appointments', 'availability']
      },
      salesforce: {
        name: 'Salesforce',
        description: 'Sync contacts and opportunities with Salesforce CRM',
        capabilities: ['contacts', 'opportunities', 'lookup']
      },
      hubspot: {
        name: 'HubSpot',
        description: 'Sync contacts and deals with HubSpot CRM',
        capabilities: ['contacts', 'deals', 'lookup']
      },
      square: {
        name: 'Square',
        description: 'Manage appointments and customers with Square',
        capabilities: ['appointments', 'customers', 'availability', 'booking']
      },
      fresha: {
        name: 'Fresha',
        description: 'Manage bookings and clients with Fresha',
        capabilities: ['appointments', 'clients', 'availability', 'booking']
      },
      outlook_calendar: {
        name: 'Outlook Calendar',
        description: 'Sync appointments with Outlook Calendar',
        capabilities: ['appointments', 'availability']
      },
      mindbody: {
        name: 'Mindbody',
        description: 'Manage appointments and clients with Mindbody',
        capabilities: ['appointments', 'clients', 'classes']
      },
      acuity: {
        name: 'Acuity Scheduling',
        description: 'Manage appointments with Acuity',
        capabilities: ['appointments', 'availability', 'booking']
      },
      calendly: {
        name: 'Calendly',
        description: 'Sync appointments with Calendly',
        capabilities: ['appointments', 'availability']
      }
    };

    return info[type] || {
      name: type,
      description: 'Unknown integration',
      capabilities: []
    };
  }
}
```

---

## 6.7 Sync Engine

```typescript
// ============================================
// SYNC ENGINE
// Handles data synchronization
// ============================================

class SyncEngine {
  constructor(private env: Env) {}

  async performSync(integrationId: string, syncType: 'full' | 'incremental'): Promise<void> {
    
    // Get integration details
    const integration = await this.env.DB
      .prepare(`
        SELECT workspace_id, integration_type, credentials_encrypted, config, last_sync_at
        FROM workspace_integrations
        WHERE id = ?
      `)
      .bind(integrationId)
      .first();

    if (!integration) {
      throw new Error('Integration not found');
    }

    // Create sync log
    const syncLogId = crypto.randomUUID();
    await this.env.DB
      .prepare(`
        INSERT INTO integration_sync_logs
        (id, integration_id, sync_type, status, started_at)
        VALUES (?, ?, ?, 'started', ?)
      `)
      .bind(syncLogId, integrationId, syncType, Date.now())
      .run();

    try {
      // Decrypt credentials
      const oauthManager = new OAuthManager(this.env);
      const tokens = await oauthManager['decryptTokens'](integration.credentials_encrypted);

      // Check if token needs refresh
      const credentials: IntegrationCredentials = {
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        expiresAt: tokens.expiresIn 
          ? Date.now() + (tokens.expiresIn * 1000)
          : undefined
      };

      if (credentials.expiresAt && credentials.expiresAt < Date.now() + 300000) {
        // Token expires in less than 5 minutes, refresh it
        await oauthManager.refreshTokens(integrationId);
        
        // Re-fetch credentials
        const updatedIntegration = await this.env.DB
          .prepare(`SELECT credentials_encrypted FROM workspace_integrations WHERE id = ?`)
          .bind(integrationId)
          .first();

        const updatedTokens = await oauthManager['decryptTokens'](
          updatedIntegration.credentials_encrypted
        );

        credentials.accessToken = updatedTokens.accessToken;
      }

      // Get connector
      const connector = ConnectorFactory.create(
        integration.integration_type as IntegrationType,
        this.env
      );

      // Parse config
      const config: SyncConfig = integration.config 
        ? JSON.parse(integration.config)
        : { direction: 'pull', resources: [] };

      // Set last sync time for incremental sync
      if (syncType === 'incremental' && integration.last_sync_at) {
        config.lastSyncAt = integration.last_sync_at;
      }

      // Perform sync
      const result = await connector.syncData(credentials, config);

      // Update sync log
      await this.env.DB
        .prepare(`
          UPDATE integration_sync_logs
          SET status = ?, records_synced = ?, completed_at = ?, error_message = ?
          WHERE id = ?
        `)
        .bind(
          result.success ? 'completed' : 'failed',
          result.recordsSynced,
          Date.now(),
          result.errors ? JSON.stringify(result.errors) : null,
          syncLogId
        )
        .run();

      // Update integration last_sync_at
      if (result.success) {
        await this.env.DB
          .prepare(`
            UPDATE workspace_integrations
            SET last_sync_at = ?, last_sync_status = 'success', updated_at = ?
            WHERE id = ?
          `)
          .bind(Date.now(), Date.now(), integrationId)
          .run();
      } else {
        await this.env.DB
          .prepare(`
            UPDATE workspace_integrations
            SET last_sync_status = 'failed', updated_at = ?
            WHERE id = ?
          `)
          .bind(Date.now(), integrationId)
          .run();
      }

    } catch (error) {
      console.error('Sync failed:', error);

      // Update sync log with error
      await this.env.DB
        .prepare(`
          UPDATE integration_sync_logs
          SET status = 'failed', error_message = ?, completed_at = ?
          WHERE id = ?
        `)
        .bind(error.message, Date.now(), syncLogId)
        .run();

      throw error;
    }
  }

  async scheduleRecurringSync(integrationId: string, intervalHours: number = 24): Promise<void> {
    
    // Use Cloudflare Cron Triggers or Queue with delay
    await this.env.SYNC_QUEUE.send(
      { integrationId, syncType: 'incremental' },
      { delaySeconds: intervalHours * 3600 }
    );
  }
}
```

---

**Continue with Part 3 of Integration Hub (Webhook handler, Integration Hub worker)?**
#vocalized