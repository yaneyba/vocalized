---
tags:
  - vocalized
  - call-management
  - pipeline
---
## 5.7 Outbound Call Manager

```typescript
// ============================================
// OUTBOUND CALL MANAGER
// Handles outbound call initiation
// ============================================

class OutboundCallManager {
  constructor(
    private env: Env,
    private router: CallRouter,
    private executor: AgentExecutor
  ) {}

  async initiateCall(
    workspaceId: string,
    agentId: string,
    toNumber: string,
    options?: {
      scheduledFor?: number;
      metadata?: Record<string, any>;
    }
  ): Promise<{ callId: string; status: string }> {
    
    // 1. Validate workspace and agent
    const { agent, phoneNumberId } = await this.router.routeOutboundCall(
      workspaceId,
      agentId,
      toNumber
    );

    // 2. Get from phone number
    const phoneNumber = await this.env.DB
      .prepare(`SELECT phone_number FROM phone_numbers WHERE id = ?`)
      .bind(phoneNumberId)
      .first();

    if (!phoneNumber) {
      throw new Error('Phone number not found');
    }

    // 3. Create call record
    const callId = crypto.randomUUID();

    await this.env.DB
      .prepare(`
        INSERT INTO calls
        (id, workspace_id, agent_id, phone_number_id, caller_number, 
         direction, status, voice_provider_used, started_at, metadata)
        VALUES (?, ?, ?, ?, ?, 'outbound', 'queued', ?, ?, ?)
      `)
      .bind(
        callId,
        workspaceId,
        agentId,
        phoneNumberId,
        toNumber,
        agent.voiceProvider,
        Date.now(),
        JSON.stringify(options?.metadata || {})
      )
      .run();

    // 4. If scheduled for later, add to queue
    if (options?.scheduledFor && options.scheduledFor > Date.now()) {
      await this.scheduleCall(callId, options.scheduledFor);
      return { callId, status: 'scheduled' };
    }

    // 5. Initiate call immediately via Twilio
    const providerCallSid = await this.makeOutboundCall(
      phoneNumber.phone_number,
      toNumber,
      callId
    );

    // 6. Update call with provider SID
    await this.env.DB
      .prepare(`
        UPDATE calls 
        SET provider_call_sid = ?, status = 'ringing'
        WHERE id = ?
      `)
      .bind(providerCallSid, callId)
      .run();

    // 7. Initialize call state
    const doId = this.env.CALL_STATE_DO.idFromName(callId);
    const doStub = this.env.CALL_STATE_DO.get(doId);

    await doStub.fetch('https://do/init', {
      method: 'POST',
      body: JSON.stringify({
        callId,
        workspaceId,
        agentId: agent.id,
        phoneNumberId,
        callerNumber: toNumber,
        direction: 'outbound',
        providerCallSid,
        voiceProvider: agent.voiceProvider,
        metadata: options?.metadata || {}
      })
    });

    return { callId, status: 'initiated' };
  }

  private async makeOutboundCall(
    fromNumber: string,
    toNumber: string,
    callId: string
  ): Promise<string> {
    
    // Twilio API call
    const twilioUrl = `https://api.twilio.com/2010-04-01/Accounts/${this.env.TWILIO_ACCOUNT_SID}/Calls.json`;
    
    const params = new URLSearchParams({
      From: fromNumber,
      To: toNumber,
      Url: `https://api.vocalized.app/webhooks/calls/outbound?callId=${callId}`,
      StatusCallback: `https://api.vocalized.app/webhooks/calls/status`,
      StatusCallbackMethod: 'POST',
      Record: 'true',
      RecordingStatusCallback: `https://api.vocalized.app/webhooks/calls/recording`,
      RecordingStatusCallbackMethod: 'POST'
    });

    const response = await fetch(twilioUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Basic ${btoa(
          `${this.env.TWILIO_ACCOUNT_SID}:${this.env.TWILIO_AUTH_TOKEN}`
        )}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: params.toString()
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Twilio API error: ${error}`);
    }

    const data = await response.json();
    return data.sid;
  }

  private async scheduleCall(
    callId: string,
    scheduledFor: number
  ): Promise<void> {
    
    // Use Cloudflare Queues to schedule the call
    await this.env.CALL_QUEUE.send({
      callId,
      scheduledFor
    }, {
      delaySeconds: Math.floor((scheduledFor - Date.now()) / 1000)
    });
  }

  async handleOutboundCallAnswered(callId: string): Promise<string> {
    
    // Get call details
    const call = await this.env.DB
      .prepare(`
        SELECT workspace_id, agent_id 
        FROM calls 
        WHERE id = ?
      `)
      .bind(callId)
      .first();

    if (!call) {
      throw new Error('Call not found');
    }

    // Get agent config
    const agent = await this.env.DB
      .prepare(`
        SELECT config, voice_provider, voice_config
        FROM voice_agents
        WHERE id = ?
      `)
      .bind(call.agent_id)
      .first();

    if (!agent) {
      throw new Error('Agent not found');
    }

    const agentConfig: AgentConfig = {
      id: call.agent_id,
      workspaceId: call.workspace_id,
      name: 'Agent',
      config: JSON.parse(agent.config),
      voiceProvider: agent.voice_provider,
      voiceConfig: JSON.parse(agent.voice_config)
    };

    // Generate greeting
    const greeting = await this.executor.handleCallStart(
      { callId } as any,
      agentConfig
    );

    return greeting;
  }
}
```

---

## 5.8 Call Queue Consumer

```typescript
// ============================================
// CALL QUEUE CONSUMER
// Processes scheduled outbound calls
// ============================================

export default {
  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    const outboundManager = new OutboundCallManager(
      env,
      new CallRouter(env),
      new AgentExecutor(env, new VoiceGateway(env))
    );

    for (const message of batch.messages) {
      try {
        const { callId, scheduledFor } = message.body;

        // Verify it's time to make the call
        if (scheduledFor > Date.now()) {
          // Not yet time, re-queue
          message.retry({ delaySeconds: 60 });
          continue;
        }

        // Get call details
        const call = await env.DB
          .prepare(`
            SELECT workspace_id, agent_id, caller_number, phone_number_id
            FROM calls
            WHERE id = ? AND status = 'queued'
          `)
          .bind(callId)
          .first();

        if (!call) {
          // Call was cancelled or already processed
          message.ack();
          continue;
        }

        // Get phone number
        const phoneNumber = await env.DB
          .prepare(`SELECT phone_number FROM phone_numbers WHERE id = ?`)
          .bind(call.phone_number_id)
          .first();

        if (!phoneNumber) {
          message.ack();
          continue;
        }

        // Initiate the call
        const providerCallSid = await outboundManager['makeOutboundCall'](
          phoneNumber.phone_number,
          call.caller_number,
          callId
        );

        // Update call status
        await env.DB
          .prepare(`
            UPDATE calls
            SET provider_call_sid = ?, status = 'ringing'
            WHERE id = ?
          `)
          .bind(providerCallSid, callId)
          .run();

        message.ack();

      } catch (error) {
        console.error('Failed to process scheduled call:', error);
        
        // Retry with exponential backoff
        message.retry();
      }
    }
  }
};
```

---

## 5.9 Recording Manager

```typescript
// ============================================
// RECORDING MANAGER
// Handles call recordings and storage
// ============================================

class RecordingManager {
  constructor(private env: Env) {}

  async storeRecording(
    callId: string,
    workspaceId: string,
    recordingData: ArrayBuffer,
    format: string = 'mp3'
  ): Promise<string> {
    
    // Generate R2 key
    const timestamp = new Date().toISOString().split('T')[0];
    const r2Key = `recordings/${workspaceId}/${timestamp}/${callId}.${format}`;

    // Upload to R2
    await this.env.R2_RECORDINGS.put(r2Key, recordingData, {
      httpMetadata: {
        contentType: format === 'mp3' ? 'audio/mpeg' : 'audio/wav'
      },
      customMetadata: {
        callId,
        workspaceId,
        uploadedAt: Date.now().toString()
      }
    });

    // Generate public URL (if R2 bucket has public access)
    const recordingUrl = `https://recordings.vocalized.app/${r2Key}`;

    // Update database
    await this.env.DB
      .prepare(`
        UPDATE calls
        SET recording_url = ?
        WHERE id = ?
      `)
      .bind(recordingUrl, callId)
      .run();

    return recordingUrl;
  }

  async getRecording(callId: string): Promise<{
    data: ReadableStream;
    contentType: string;
  } | null> {
    
    // Get recording URL from database
    const call = await this.env.DB
      .prepare(`SELECT recording_url FROM calls WHERE id = ?`)
      .bind(callId)
      .first();

    if (!call || !call.recording_url) {
      return null;
    }

    // Extract R2 key from URL
    const url = new URL(call.recording_url);
    const r2Key = url.pathname.substring(1); // Remove leading /

    // Get from R2
    const object = await this.env.R2_RECORDINGS.get(r2Key);

    if (!object) {
      return null;
    }

    return {
      data: object.body,
      contentType: object.httpMetadata?.contentType || 'audio/mpeg'
    };
  }

  async deleteRecording(callId: string): Promise<boolean> {
    
    // Get recording URL
    const call = await this.env.DB
      .prepare(`SELECT recording_url FROM calls WHERE id = ?`)
      .bind(callId)
      .first();

    if (!call || !call.recording_url) {
      return false;
    }

    // Extract R2 key
    const url = new URL(call.recording_url);
    const r2Key = url.pathname.substring(1);

    // Delete from R2
    await this.env.R2_RECORDINGS.delete(r2Key);

    // Update database
    await this.env.DB
      .prepare(`
        UPDATE calls
        SET recording_url = NULL
        WHERE id = ?
      `)
      .bind(callId)
      .run();

    return true;
  }

  async transcribeRecording(
    callId: string,
    workspaceId: string
  ): Promise<string> {
    
    // Get recording
    const recording = await this.getRecording(callId);

    if (!recording) {
      throw new Error('Recording not found');
    }

    // Convert stream to ArrayBuffer
    const chunks: Uint8Array[] = [];
    const reader = recording.data.getReader();

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
    }

    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const audioBuffer = new Uint8Array(totalLength);
    let offset = 0;

    for (const chunk of chunks) {
      audioBuffer.set(chunk, offset);
      offset += chunk.length;
    }

    // Transcribe using Voice Gateway
    const gateway = new VoiceGateway(this.env);

    const transcription = await gateway.transcribe({
      workspaceId,
      operation: 'transcribe',
      audio: audioBuffer.buffer,
      transcribeConfig: {
        punctuate: true,
        diarize: true
      }
    });

    // Save transcription
    await this.env.DB
      .prepare(`
        UPDATE calls
        SET transcription = ?
        WHERE id = ?
      `)
      .bind(transcription.text, callId)
      .run();

    return transcription.text;
  }

  async generateCallSummary(callId: string): Promise<string> {
    
    // Get call details
    const call = await this.env.DB
      .prepare(`
        SELECT transcription, metadata
        FROM calls
        WHERE id = ?
      `)
      .bind(callId)
      .first();

    if (!call || !call.transcription) {
      return 'No transcription available';
    }

    // In production, use an LLM to generate summary
    // For now, return a simple summary
    const wordCount = call.transcription.split(' ').length;
    const summary = `Call with approximately ${wordCount} words transcribed.`;

    // Save summary
    await this.env.DB
      .prepare(`
        UPDATE calls
        SET summary = ?
        WHERE id = ?
      `)
      .bind(summary, callId)
      .run();

    return summary;
  }
}
```

---

## 5.10 Call Analytics

```typescript
// ============================================
// CALL ANALYTICS
// Real-time call analytics and metrics
// ============================================

class CallAnalytics {
  constructor(private env: Env) {}

  async getWorkspaceCallStats(
    workspaceId: string,
    period: 'day' | 'week' | 'month' = 'day'
  ): Promise<{
    totalCalls: number;
    completedCalls: number;
    failedCalls: number;
    avgDuration: number;
    totalMinutes: number;
    callsByStatus: Record<string, number>;
    callsByDirection: Record<string, number>;
    peakHours: Array<{ hour: number; count: number }>;
  }> {
    
    const now = Date.now();
    const periodStart = this.getPeriodStart(now, period);

    // Get call statistics
    const stats = await this.env.DB
      .prepare(`
        SELECT 
          COUNT(*) as total_calls,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_calls,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_calls,
          AVG(duration_seconds) as avg_duration,
          SUM(duration_seconds) as total_seconds
        FROM calls
        WHERE workspace_id = ? AND started_at >= ?
      `)
      .bind(workspaceId, periodStart)
      .first();

    // Get calls by status
    const byStatus = await this.env.DB
      .prepare(`
        SELECT status, COUNT(*) as count
        FROM calls
        WHERE workspace_id = ? AND started_at >= ?
        GROUP BY status
      `)
      .bind(workspaceId, periodStart)
      .all();

    // Get calls by direction
    const byDirection = await this.env.DB
      .prepare(`
        SELECT direction, COUNT(*) as count
        FROM calls
        WHERE workspace_id = ? AND started_at >= ?
        GROUP BY direction
      `)
      .bind(workspaceId, periodStart)
      .all();

    // Get peak hours
    const peakHours = await this.env.DB
      .prepare(`
        SELECT 
          CAST((started_at / 3600000) % 24 AS INTEGER) as hour,
          COUNT(*) as count
        FROM calls
        WHERE workspace_id = ? AND started_at >= ?
        GROUP BY hour
        ORDER BY count DESC
        LIMIT 5
      `)
      .bind(workspaceId, periodStart)
      .all();

    return {
      totalCalls: stats.total_calls || 0,
      completedCalls: stats.completed_calls || 0,
      failedCalls: stats.failed_calls || 0,
      avgDuration: Math.round(stats.avg_duration || 0),
      totalMinutes: Math.round((stats.total_seconds || 0) / 60),
      callsByStatus: Object.fromEntries(
        byStatus.results.map(r => [r.status, r.count])
      ),
      callsByDirection: Object.fromEntries(
        byDirection.results.map(r => [r.direction, r.count])
      ),
      peakHours: peakHours.results.map(r => ({
        hour: r.hour,
        count: r.count
      }))
    };
  }

  async getAgentPerformance(
    agentId: string,
    period: 'day' | 'week' | 'month' = 'month'
  ): Promise<{
    totalCalls: number;
    avgDuration: number;
    successRate: number;
    sentimentScore: number;
  }> {
    
    const now = Date.now();
    const periodStart = this.getPeriodStart(now, period);

    const stats = await this.env.DB
      .prepare(`
        SELECT 
          COUNT(*) as total_calls,
          AVG(duration_seconds) as avg_duration,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
          AVG(CASE 
            WHEN sentiment = 'positive' THEN 1.0
            WHEN sentiment = 'neutral' THEN 0.5
            WHEN sentiment = 'negative' THEN 0.0
            ELSE 0.5
          END) as sentiment_avg
        FROM calls
        WHERE agent_id = ? AND started_at >= ?
      `)
      .bind(agentId, periodStart)
      .first();

    const totalCalls = stats.total_calls || 0;
    const completed = stats.completed || 0;

    return {
      totalCalls,
      avgDuration: Math.round(stats.avg_duration || 0),
      successRate: totalCalls > 0 ? (completed / totalCalls) * 100 : 0,
      sentimentScore: (stats.sentiment_avg || 0.5) * 100
    };
  }

  async getLiveCallsCount(workspaceId: string): Promise<number> {
    
    const result = await this.env.DB
      .prepare(`
        SELECT COUNT(*) as count
        FROM calls
        WHERE workspace_id = ? AND status IN ('ringing', 'in-progress')
      `)
      .bind(workspaceId)
      .first();

    return result.count || 0;
  }

  async getCallCostBreakdown(
    workspaceId: string,
    period: 'day' | 'week' | 'month' = 'month'
  ): Promise<{
    totalCost: number;
    byProvider: Array<{ provider: string; cost: number; count: number }>;
    byResourceType: Array<{ type: string; cost: number }>;
  }> {
    
    const now = Date.now();
    const periodStart = this.getPeriodStart(now, period);

    // Get total cost
    const total = await this.env.DB
      .prepare(`
        SELECT SUM(final_cost) as total
        FROM usage_records
        WHERE workspace_id = ? AND created_at >= ?
      `)
      .bind(workspaceId, periodStart)
      .first();

    // By provider
    const byProvider = await this.env.DB
      .prepare(`
        SELECT 
          provider,
          SUM(final_cost) as cost,
          COUNT(DISTINCT call_id) as count
        FROM usage_records
        WHERE workspace_id = ? AND created_at >= ?
        GROUP BY provider
      `)
      .bind(workspaceId, periodStart)
      .all();

    // By resource type
    const byResourceType = await this.env.DB
      .prepare(`
        SELECT 
          resource_type as type,
          SUM(final_cost) as cost
        FROM usage_records
        WHERE workspace_id = ? AND created_at >= ?
        GROUP BY resource_type
      `)
      .bind(workspaceId, periodStart)
      .all();

    return {
      totalCost: total.total || 0,
      byProvider: byProvider.results.map(r => ({
        provider: r.provider,
        cost: r.cost,
        count: r.count
      })),
      byResourceType: byResourceType.results.map(r => ({
        type: r.type,
        cost: r.cost
      }))
    };
  }

  private getPeriodStart(now: number, period: 'day' | 'week' | 'month'): number {
    const date = new Date(now);

    switch (period) {
      case 'day':
        date.setHours(0, 0, 0, 0);
        break;
      case 'week':
        date.setDate(date.getDate() - 7);
        date.setHours(0, 0, 0, 0);
        break;
      case 'month':
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        break;
    }

    return date.getTime();
  }
}
```

---

## 5.11 Call Management Worker Entry Point

```typescript
// ============================================
// CALL MANAGEMENT WORKER
// Main entry point for call handling
// ============================================

export { CallStateDO };

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // Initialize dependencies
      const gateway = new VoiceGateway(env);
      const router = new CallRouter(env);
      const executor = new AgentExecutor(env, gateway);
      const webhookHandler = new WebhookHandler(env, router, executor);
      const outboundManager = new OutboundCallManager(env, router, executor);
      const recordingManager = new RecordingManager(env);
      const analytics = new CallAnalytics(env);

      // Webhook routes
      if (path === '/webhooks/calls/inbound' && request.method === 'POST') {
        const formData = await request.formData();
        const webhook = Object.fromEntries(formData) as any;
        return await webhookHandler.handleInboundCall(webhook);
      }

      if (path === '/webhooks/calls/outbound' && request.method === 'POST') {
        const callId = url.searchParams.get('callId');
        if (!callId) {
          return new Response('Missing callId', { status: 400 });
        }

        const greeting = await outboundManager.handleOutboundCallAnswered(callId);
        
        const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">${greeting}</Say>
  <Gather input="speech" action="/webhooks/calls/gather?callId=${callId}" method="POST">
    <Say>How can I help you?</Say>
  </Gather>
  <Hangup/>
</Response>`;

        return new Response(twiml, {
          headers: { 'Content-Type': 'text/xml' }
        });
      }

      if (path === '/webhooks/calls/status' && request.method === 'POST') {
        const formData = await request.formData();
        const webhook = Object.fromEntries(formData) as any;
        return await webhookHandler.handleStatusUpdate(webhook);
      }

      if (path === '/webhooks/calls/recording' && request.method === 'POST') {
        const formData = await request.formData();
        const webhook = Object.fromEntries(formData) as any;
        return await webhookHandler.handleRecording(webhook);
      }

      if (path === '/webhooks/calls/gather' && request.method === 'POST') {
        const callId = url.searchParams.get('callId');
        const formData = await request.formData();
        const speechResult = formData.get('SpeechResult') as string;

        if (!callId || !speechResult) {
          return new Response('Missing parameters', { status: 400 });
        }

        // Get call state
        const call = await env.DB
          .prepare(`SELECT workspace_id, agent_id FROM calls WHERE id = ?`)
          .bind(callId)
          .first();

        if (!call) {
          return new Response('Call not found', { status: 404 });
        }

        // Get agent
        const agent = await env.DB
          .prepare(`
            SELECT config, voice_provider, voice_config
            FROM voice_agents WHERE id = ?
          `)
          .bind(call.agent_id)
          .first();

        const agentConfig: AgentConfig = {
          id: call.agent_id,
          workspaceId: call.workspace_id,
          name: 'Agent',
          config: JSON.parse(agent.config),
          voiceProvider: agent.voice_provider,
          voiceConfig: JSON.parse(agent.voice_config)
        };

        // Get call state from DO
        const doId = env.CALL_STATE_DO.idFromName(callId);
        const doStub = env.CALL_STATE_DO.get(doId);
        const stateResponse = await doStub.fetch('https://do/state');
        const callState = await stateResponse.json();

        // Handle user input
        const response = await executor.handleUserInput(
          callState,
          agentConfig,
          speechResult
        );

        // Add assistant turn
        await doStub.fetch('https://do/add-turn', {
          method: 'POST',
          body: JSON.stringify({
            role: 'assistant',
            content: response,
            timestamp: Date.now()
          })
        });

        // Continue conversation
        const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">${response}</Say>
  <Gather input="speech" action="/webhooks/calls/gather?callId=${callId}" method="POST" timeout="5">
    <Say>Is there anything else I can help you with?</Say>
  </Gather>
  <Say>Thank you for calling. Goodbye!</Say>
  <Hangup/>
</Response>`;

        return new Response(twiml, {
          headers: { 'Content-Type': 'text/xml' }
        });
      }

      // API routes (require authentication)
      const auth = await authorize(request, env);

      // Initiate outbound call
      if (path.match(/^\/workspaces\/[^/]+\/calls\/outbound$/) && request.method === 'POST') {
        const match = path.match(/^\/workspaces\/([^/]+)\/calls\/outbound$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);

        const body = await request.json();
        const result = await outboundManager.initiateCall(
          workspaceId,
          body.agentId,
          body.toNumber,
          {
            scheduledFor: body.scheduledFor,
            metadata: body.metadata
          }
        );

        return Response.json(result, { headers: corsHeaders });
      }

      // Get call recording
      if (path.match(/^\/workspaces\/[^/]+\/calls\/[^/]+\/recording$/) && request.method === 'GET') {
        const match = path.match(/^\/workspaces\/([^/]+)\/calls\/([^/]+)\/recording$/);
        const workspaceId = match![1];
        const callId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId);

        const recording = await recordingManager.getRecording(callId);

        if (!recording) {
          return Response.json(
            { error: 'Recording not found' },
            { status: 404, headers: corsHeaders }
          );
        }

        return new Response(recording.data, {
          headers: {
            ...corsHeaders,
            'Content-Type': recording.contentType
          }
        });
      }

      // Get analytics
      if (path.match(/^\/workspaces\/[^/]+\/analytics\/calls$/) && request.method === 'GET') {
        const match = path.match(/^\/workspaces\/([^/]+)\/analytics\/calls$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const period = (url.searchParams.get('period') as any) || 'day';
        const stats = await analytics.getWorkspaceCallStats(workspaceId, period);

        return Response.json(stats, { headers: corsHeaders });
      }

      return Response.json(
        { error: 'Not found' },
        { status: 404, headers: corsHeaders }
      );

    } catch (error) {
      console.error('Call management error:', error);

      return Response.json(
        { error: error.message },
        { status: 500, headers: corsHeaders }
      );
    }
  },

  // Queue consumer for scheduled calls
  async queue(batch: MessageBatch<any>, env: Env): Promise<void> {
    const gateway = new VoiceGateway(env);
    const router = new CallRouter(env);
    const executor = new AgentExecutor(env, gateway);
    const outboundManager = new OutboundCallManager(env, router, executor);

    for (const message of batch.messages) {
      try {
        const { callId, scheduledFor } = message.body;

        if (scheduledFor > Date.now()) {
          message.retry({ delaySeconds: 60 });
          continue;
        }

        const call = await env.DB
          .prepare(`
            SELECT workspace_id, agent_id, caller_number, phone_number_id
            FROM calls
            WHERE id = ? AND status = 'queued'
          `)
          .bind(callId)
          .first();

        if (!call) {
          message.ack();
          continue;
        }

        const phoneNumber = await env.DB
          .prepare(`SELECT phone_number FROM phone_numbers WHERE id = ?`)
          .bind(call.phone_number_id)
          .first();

        if (!phoneNumber) {
          message.ack();
          continue;
        }

        const providerCallSid = await outboundManager['makeOutboundCall'](
          phoneNumber.phone_number,
          call.caller_number,
          callId
        );

        await env.DB
          .prepare(`
            UPDATE calls
            SET provider_call_sid = ?, status = 'ringing'
            WHERE id = ?
          `)
          .bind(providerCallSid, callId)
          .run();

        message.ack();

      } catch (error) {
        console.error('Failed to process scheduled call:', error);
        message.retry();
      }
    }
  }
};
```

---

**This completes the Call Management Engine. Ready for the next section?**
#vocalized