---
tags:
  - pipeline
  - analytics
  - billing
---
## 7.7 Billing & Analytics Worker

```typescript
// ============================================
// BILLING & ANALYTICS WORKER
// Main entry point
// ============================================

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      const usageTracker = new UsageTracker(env);
      const billingEngine = new BillingEngine(env);
      const analytics = new AnalyticsEngine(env);
      const reportGenerator = new ReportGenerator(env, analytics);

      // ==========================================
      // CLIENT BILLING ENDPOINTS
      // ==========================================

      // Get current billing period
      if (path.match(/^\/workspaces\/[^/]+\/billing\/current$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/billing\/current$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const summary = await usageTracker.getUsageSummary(workspaceId);

        // Get billing settings
        const settings = await env.DB
          .prepare(`
            SELECT usage_limit_monthly, alert_threshold_percentage
            FROM workspace_billing_settings
            WHERE workspace_id = ?
          `)
          .bind(workspaceId)
          .first();

        const percentageUsed = settings?.usage_limit_monthly
          ? (summary.totalAmount / settings.usage_limit_monthly) * 100
          : 0;

        return Response.json(
          {
            ...summary,
            usageLimit: settings?.usage_limit_monthly || null,
            percentageUsed,
            alertThreshold: settings?.alert_threshold_percentage || 80
          },
          { headers: corsHeaders }
        );
      }

      // Get billing history
      if (path.match(/^\/workspaces\/[^/]+\/billing\/history$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/billing\/history$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const periods = await env.DB
          .prepare(`
            SELECT 
              id, period_start, period_end, subtotal, 
              subscription_fee, total_amount, status, paid_at
            FROM billing_periods
            WHERE workspace_id = ?
            ORDER BY period_start DESC
            LIMIT 12
          `)
          .bind(workspaceId)
          .all();

        return Response.json(
          { periods: periods.results },
          { headers: corsHeaders }
        );
      }

      // Get invoices
      if (path.match(/^\/workspaces\/[^/]+\/billing\/invoices$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/billing\/invoices$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const invoices = await env.DB
          .prepare(`
            SELECT 
              bp.id,
              bp.period_start,
              bp.period_end,
              bp.total_amount,
              bp.status,
              bp.stripe_invoice_id,
              bp.paid_at
            FROM billing_periods bp
            WHERE bp.workspace_id = ?
            AND bp.status IN ('finalized', 'paid', 'overdue')
            ORDER BY bp.period_start DESC
          `)
          .bind(workspaceId)
          .all();

        return Response.json(
          { invoices: invoices.results },
          { headers: corsHeaders }
        );
      }

      // Get invoice details
      if (path.match(/^\/workspaces\/[^/]+\/billing\/invoices\/[^/]+$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/billing\/invoices\/([^/]+)$/);
        const workspaceId = match![1];
        const invoiceId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId);

        const invoice = await env.DB
          .prepare(`
            SELECT * FROM billing_periods
            WHERE id = ? AND workspace_id = ?
          `)
          .bind(invoiceId, workspaceId)
          .first();

        if (!invoice) {
          return Response.json(
            { error: 'Invoice not found' },
            { status: 404, headers: corsHeaders }
          );
        }

        // Get usage breakdown
        const usage = await env.DB
          .prepare(`
            SELECT 
              resource_type,
              provider,
              SUM(quantity) as total_quantity,
              SUM(final_cost) as total_cost
            FROM usage_records
            WHERE billing_period_id = ?
            GROUP BY resource_type, provider
          `)
          .bind(invoiceId)
          .all();

        return Response.json(
          {
            invoice,
            lineItems: usage.results
          },
          { headers: corsHeaders }
        );
      }

      // Update billing settings
      if (path.match(/^\/workspaces\/[^/]+\/billing\/settings$/) && request.method === 'PUT') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/billing\/settings$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId, ['owner', 'admin']);

        const body = await request.json();

        await env.DB
          .prepare(`
            INSERT OR REPLACE INTO workspace_billing_settings
            (workspace_id, usage_limit_monthly, alert_threshold_percentage, 
             auto_pause_on_limit, billing_email, updated_at)
            VALUES (?, ?, ?, ?, ?, ?)
          `)
          .bind(
            workspaceId,
            body.usageLimit || null,
            body.alertThreshold || 80,
            body.autoPause ? 1 : 0,
            body.billingEmail || null,
            Date.now()
          )
          .run();

        return Response.json({ success: true }, { headers: corsHeaders });
      }

      // ==========================================
      // CLIENT ANALYTICS ENDPOINTS
      // ==========================================

      // Get workspace overview
      if (path.match(/^\/workspaces\/[^/]+\/analytics\/overview$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/analytics\/overview$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const period = (url.searchParams.get('period') as any) || 'month';
        const overview = await analytics.getWorkspaceOverview(workspaceId, period);

        return Response.json(overview, { headers: corsHeaders });
      }

      // Get call analytics
      if (path.match(/^\/workspaces\/[^/]+\/analytics\/calls$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/analytics\/calls$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const filters = {
          agentId: url.searchParams.get('agentId') || undefined,
          status: url.searchParams.get('status') || undefined,
          direction: url.searchParams.get('direction') || undefined,
          startDate: url.searchParams.get('startDate') 
            ? parseInt(url.searchParams.get('startDate')!)
            : undefined,
          endDate: url.searchParams.get('endDate')
            ? parseInt(url.searchParams.get('endDate')!)
            : undefined
        };

        const callAnalytics = await analytics.getCallAnalytics(workspaceId, filters);

        return Response.json(callAnalytics, { headers: corsHeaders });
      }

      // Get agent performance
      if (path.match(/^\/workspaces\/[^/]+\/agents\/[^/]+\/analytics$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/agents\/([^/]+)\/analytics$/);
        const workspaceId = match![1];
        const agentId = match![2];

        await enforceWorkspaceAccess(auth, workspaceId);

        const period = (url.searchParams.get('period') as any) || 'month';
        const performance = await analytics.getAgentPerformance(agentId, period);

        return Response.json(performance, { headers: corsHeaders });
      }

      // Export analytics
      if (path.match(/^\/workspaces\/[^/]+\/analytics\/export$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/analytics\/export$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const format = (url.searchParams.get('format') as 'csv' | 'json') || 'csv';
        const startDate = parseInt(url.searchParams.get('startDate') || '0');
        const endDate = parseInt(url.searchParams.get('endDate') || Date.now().toString());

        const data = await analytics.exportAnalytics(
          workspaceId,
          format,
          startDate,
          endDate
        );

        const contentType = format === 'csv' 
          ? 'text/csv'
          : 'application/json';

        const filename = `analytics-${workspaceId}-${Date.now()}.${format}`;

        return new Response(data, {
          headers: {
            ...corsHeaders,
            'Content-Type': contentType,
            'Content-Disposition': `attachment; filename="${filename}"`
          }
        });
      }

      // Generate monthly report
      if (path.match(/^\/workspaces\/[^/]+\/reports\/monthly$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/reports\/monthly$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const year = parseInt(url.searchParams.get('year') || new Date().getFullYear().toString());
        const month = parseInt(url.searchParams.get('month') || (new Date().getMonth() + 1).toString());

        const report = await reportGenerator.generateMonthlyReport(
          workspaceId,
          year,
          month
        );

        return Response.json(report, { headers: corsHeaders });
      }

      // Generate executive summary
      if (path.match(/^\/workspaces\/[^/]+\/reports\/executive$/) && request.method === 'GET') {
        const auth = await authorize(request, env);
        const match = path.match(/^\/workspaces\/([^/]+)\/reports\/executive$/);
        const workspaceId = match![1];

        await enforceWorkspaceAccess(auth, workspaceId);

        const quarter = parseInt(url.searchParams.get('quarter') || '1');
        const year = parseInt(url.searchParams.get('year') || new Date().getFullYear().toString());

        const summary = await reportGenerator.generateExecutiveSummary(
          workspaceId,
          quarter,
          year
        );

        return new Response(summary, {
          headers: {
            ...corsHeaders,
            'Content-Type': 'text/markdown',
            'Content-Disposition': `attachment; filename="executive-summary-q${quarter}-${year}.md"`
          }
        });
      }

      // ==========================================
      // ADMIN ANALYTICS ENDPOINTS
      // ==========================================

      // Get platform overview
      if (path === '/admin/analytics/overview' && request.method === 'GET') {
        const auth = await authorize(request, env);

        if (auth.type !== 'admin') {
          return Response.json(
            { error: 'Admin access required' },
            { status: 403, headers: corsHeaders }
          );
        }

        const overview = await analytics.getPlatformOverview();

        return Response.json(overview, { headers: corsHeaders });
      }

      // Get provider analytics
      if (path === '/admin/analytics/providers' && request.method === 'GET') {
        const auth = await authorize(request, env);

        if (auth.type !== 'admin') {
          return Response.json(
            { error: 'Admin access required' },
            { status: 403, headers: corsHeaders }
          );
        }

        const period = (url.searchParams.get('period') as any) || 'month';
        const providerAnalytics = await analytics.getProviderAnalytics(period);

        return Response.json(
          { providers: providerAnalytics },
          { headers: corsHeaders }
        );
      }

      // Admin billing operations
      if (path.match(/^\/admin\/billing\/periods\/[^/]+\/finalize$/) && request.method === 'POST') {
        const auth = await authorize(request, env);

        if (auth.type !== 'admin' || auth.admin_role !== 'super_admin') {
          return Response.json(
            { error: 'Super admin access required' },
            { status: 403, headers: corsHeaders }
          );
        }

        const match = path.match(/^\/admin\/billing\/periods\/([^/]+)\/finalize$/);
        const periodId = match![1];

        await billingEngine.finalizeBillingPeriod(periodId);

        return Response.json({ success: true }, { headers: corsHeaders });
      }

      // Stripe webhook
      if (path === '/webhooks/stripe' && request.method === 'POST') {
        return await billingEngine.handleStripeWebhook(request);
      }

      return Response.json(
        { error: 'Not found' },
        { status: 404, headers: corsHeaders }
      );

    } catch (error) {
      console.error('Billing & Analytics error:', error);

      return Response.json(
        { error: error.message },
        { status: 500, headers: corsHeaders }
      );
    }
  },

  // Scheduled jobs
  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {
    const cron = event.cron;

    try {
      // Daily at midnight UTC - Update usage totals
      if (cron === '0 0 * * *') {
        console.log('Running daily usage update...');
        await updateDailyUsage(env);
      }

      // First day of month at 1 AM UTC - Finalize billing periods
      if (cron === '0 1 1 * *') {
        console.log('Running monthly billing finalization...');
        await finalizeMonthlyBilling(env);
      }

      // Every hour - Check usage limits
      if (cron === '0 * * * *') {
        console.log('Running usage limit checks...');
        await checkUsageLimits(env);
      }

      // Daily at 2 AM UTC - Generate daily reports
      if (cron === '0 2 * * *') {
        console.log('Generating daily reports...');
        await generateDailyReports(env);
      }

    } catch (error) {
      console.error('Scheduled job error:', error);
    }
  }
};

// ==========================================
// SCHEDULED JOB FUNCTIONS
// ==========================================

async function updateDailyUsage(env: Env): Promise<void> {
  // Update usage totals for all current billing periods
  const periods = await env.DB
    .prepare(`
      SELECT id FROM billing_periods
      WHERE status = 'current'
    `)
    .all();

  const usageTracker = new UsageTracker(env);

  for (const period of periods.results) {
    await usageTracker['updateBillingPeriodTotals'](period.id);
  }

  console.log(`Updated ${periods.results.length} billing periods`);
}

async function finalizeMonthlyBilling(env: Env): Promise<void> {
  // Get all current billing periods that ended last month
  const lastMonth = new Date();
  lastMonth.setMonth(lastMonth.getMonth() - 1);
  lastMonth.setDate(1);
  lastMonth.setHours(0, 0, 0, 0);

  const periods = await env.DB
    .prepare(`
      SELECT id FROM billing_periods
      WHERE status = 'current'
      AND period_end < ?
    `)
    .bind(Date.now())
    .all();

  const billingEngine = new BillingEngine(env);

  for (const period of periods.results) {
    try {
      await billingEngine.finalizeBillingPeriod(period.id);
      console.log(`Finalized billing period: ${period.id}`);
    } catch (error) {
      console.error(`Failed to finalize period ${period.id}:`, error);
    }
  }

  console.log(`Finalized ${periods.results.length} billing periods`);
}

async function checkUsageLimits(env: Env): Promise<void> {
  // Get all active workspaces with usage limits
  const workspaces = await env.DB
    .prepare(`
      SELECT DISTINCT ws.workspace_id
      FROM workspace_billing_settings ws
      JOIN workspaces w ON ws.workspace_id = w.id
      WHERE w.status = 'active'
      AND ws.usage_limit_monthly IS NOT NULL
    `)
    .all();

  const usageTracker = new UsageTracker(env);

  for (const workspace of workspaces.results) {
    try {
      await usageTracker['checkUsageLimits'](workspace.workspace_id);
    } catch (error) {
      console.error(`Failed to check limits for ${workspace.workspace_id}:`, error);
    }
  }

  console.log(`Checked usage limits for ${workspaces.results.length} workspaces`);
}

async function generateDailyReports(env: Env): Promise<void> {
  // Generate daily summary reports for admin
  const analytics = new AnalyticsEngine(env);
  const overview = await analytics.getPlatformOverview();

  console.log('Daily Platform Summary:');
  console.log(`- Total Workspaces: ${overview.totalWorkspaces}`);
  console.log(`- Active Workspaces: ${overview.activeWorkspaces}`);
  console.log(`- Total Calls (30d): ${overview.totalCalls}`);
  console.log(`- Total Revenue (30d): $${overview.totalRevenue.toFixed(2)}`);
  console.log(`- MRR: $${overview.mrr.toFixed(2)}`);
  console.log(`- Churn Rate: ${overview.churnRate.toFixed(2)}%`);

  // Store report in database or send via email
  await env.DB
    .prepare(`
      INSERT INTO daily_reports
      (id, report_date, data, created_at)
      VALUES (?, ?, ?, ?)
    `)
    .bind(
      crypto.randomUUID(),
      new Date().toISOString().split('T')[0],
      JSON.stringify(overview),
      Date.now()
    )
    .run();
}

// Add to schema
/*
CREATE TABLE daily_reports (
    id TEXT PRIMARY KEY,
    report_date TEXT NOT NULL,
    data TEXT NOT NULL, -- JSON
    created_at INTEGER NOT NULL
);

CREATE INDEX idx_daily_reports_date ON daily_reports(report_date);
*/
```

---

## 7.8 Scheduled Cron Configuration

```toml
# wrangler.toml

# Add these to your wrangler.toml file

# Daily usage update - midnight UTC
[[triggers.crons]]
schedule = "0 0 * * *"

# Monthly billing finalization - 1st of month at 1 AM UTC
[[triggers.crons]]
schedule = "0 1 1 * *"

# Hourly usage limit checks
[[triggers.crons]]
schedule = "0 * * * *"

# Daily reports - 2 AM UTC
[[triggers.crons]]
schedule = "0 2 * * *"
```

---

## 7.9 Stripe Integration Setup

```typescript
// ============================================
// STRIPE INTEGRATION HELPERS
// ============================================

class StripeHelper {
  constructor(private env: Env) {}

  async createCustomer(
    email: string,
    name: string,
    workspaceId: string
  ): Promise<string> {
    
    const response = await fetch('https://api.stripe.com/v1/customers', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        email,
        name,
        metadata: JSON.stringify({ workspaceId })
      })
    });

    if (!response.ok) {
      throw new Error('Failed to create Stripe customer');
    }

    const customer = await response.json();

    // Store customer ID
    await this.env.DB
      .prepare(`
        UPDATE workspaces
        SET metadata = json_set(COALESCE(metadata, '{}'), '$.stripeCustomerId', ?)
        WHERE id = ?
      `)
      .bind(customer.id, workspaceId)
      .run();

    return customer.id;
  }

  async createPaymentMethod(
    customerId: string,
    paymentMethodId: string
  ): Promise<void> {
    
    // Attach payment method to customer
    await fetch(`https://api.stripe.com/v1/payment_methods/${paymentMethodId}/attach`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({ customer: customerId })
    });

    // Set as default payment method
    await fetch(`https://api.stripe.com/v1/customers/${customerId}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        invoice_settings: JSON.stringify({
          default_payment_method: paymentMethodId
        })
      })
    });
  }

  async createSubscription(
    customerId: string,
    priceId: string
  ): Promise<string> {
    
    const response = await fetch('https://api.stripe.com/v1/subscriptions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        customer: customerId,
        items: JSON.stringify([{ price: priceId }])
      })
    });

    if (!response.ok) {
      throw new Error('Failed to create subscription');
    }

    const subscription = await response.json();
    return subscription.id;
  }
}
```

---

**This completes the Billing & Analytics system. Ready for the final section (Deployment & Configuration)?**
#vocalized