---
tags:
  - pipeline
  - analytics
  - billing
---
## 7.1 Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                  Billing & Analytics System                 │
│                                                             │
│  ┌──────────────┐         ┌──────────────┐                  │
│  │   Usage      │────────▶│   Billing    │                  │
│  │   Tracker    │         │   Engine     │                  │
│  └──────────────┘         └──────────────┘                  │
│         │                          │                        │
│         │                          ▼                        │
│         │                  ┌──────────────┐                 │
│         │                  │   Stripe     │                 │
│         │                  │   Integration│                 │
│         │                  └──────────────┘                 │
│         ▼                          │                        │
│  ┌──────────────┐         ┌──────────────┐                  │
│  │  Analytics   │         │   Invoice    │                  │
│  │  Engine      │         │   Generator  │                  │
│  └──────────────┘         └──────────────┘                  │
│         │                          │                        │
│         ▼                          ▼                        │
│  ┌─────────────────────────────────────────┐                │
│  │         Reporting & Dashboards          │                │
│  └─────────────────────────────────────────┘                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7.2 Core Types

```typescript
// ============================================
// BILLING & ANALYTICS TYPES
// ============================================

interface UsageRecord {
  id: string;
  workspaceId: string;
  callId?: string;
  resourceType: string; // call_minutes, transcription, synthesis, storage
  provider: string;
  quantity: number;
  unitCost: number;
  totalCost: number;
  markupPercentage: number;
  finalCost: number;
  billingPeriodId: string;
  createdAt: number;
}

interface BillingPeriod {
  id: string;
  workspaceId: string;
  periodStart: number;
  periodEnd: number;
  subtotal: number;
  subscriptionFee: number;
  totalAmount: number;
  status: 'current' | 'finalized' | 'paid' | 'overdue';
  stripeInvoiceId?: string;
  paidAt?: number;
}

interface Invoice {
  id: string;
  workspaceId: string;
  billingPeriodId: string;
  invoiceNumber: string;
  amount: number;
  status: string;
  dueDate: number;
  paidAt?: number;
  items: InvoiceItem[];
}

interface InvoiceItem {
  description: string;
  quantity: number;
  unitPrice: number;
  amount: number;
}

interface AnalyticsMetrics {
  totalCalls: number;
  totalMinutes: number;
  totalCost: number;
  avgCallDuration: number;
  successRate: number;
  byProvider: Record<string, { calls: number; cost: number }>;
  byStatus: Record<string, number>;
  byDirection: Record<string, number>;
  peakHours: Array<{ hour: number; count: number }>;
}
```

---

## 7.3 Usage Tracker

```typescript
// ============================================
// USAGE TRACKER
// Tracks all billable usage
// ============================================

class UsageTracker {
  constructor(private env: Env) {}

  async trackUsage(
    workspaceId: string,
    usage: {
      callId?: string;
      resourceType: string;
      provider: string;
      quantity: number;
      unitCost: number;
    }
  ): Promise<void> {
    
    // Get workspace markup
    const markup = await this.getWorkspaceMarkup(workspaceId);
    
    // Calculate costs
    const totalCost = usage.quantity * usage.unitCost;
    const finalCost = totalCost * (1 + markup / 100);

    // Get or create current billing period
    const billingPeriod = await this.getCurrentBillingPeriod(workspaceId);

    // Create usage record
    const usageId = crypto.randomUUID();

    await this.env.DB
      .prepare(`
        INSERT INTO usage_records
        (id, workspace_id, call_id, resource_type, provider, quantity, 
         unit_cost, total_cost, markup_percentage, final_cost, 
         billing_period_id, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .bind(
        usageId,
        workspaceId,
        usage.callId || null,
        usage.resourceType,
        usage.provider,
        usage.quantity,
        usage.unitCost,
        totalCost,
        markup,
        finalCost,
        billingPeriod,
        Date.now()
      )
      .run();

    // Update billing period totals
    await this.updateBillingPeriodTotals(billingPeriod);

    // Check usage limits
    await this.checkUsageLimits(workspaceId);
  }

  private async getWorkspaceMarkup(workspaceId: string): Promise<number> {
    // Get workspace-specific markup or use platform default
    const setting = await this.env.DB
      .prepare(`
        SELECT value FROM platform_settings 
        WHERE key = 'pricing_markup_percentage'
      `)
      .first();

    return setting ? parseFloat(setting.value) : 20; // Default 20%
  }

  private async getCurrentBillingPeriod(workspaceId: string): Promise<string> {
    // Check for existing current period
    const existing = await this.env.DB
      .prepare(`
        SELECT id FROM billing_periods
        WHERE workspace_id = ? AND status = 'current'
      `)
      .bind(workspaceId)
      .first();

    if (existing) {
      return existing.id;
    }

    // Create new billing period
    return await this.createBillingPeriod(workspaceId);
  }

  private async createBillingPeriod(workspaceId: string): Promise<string> {
    const now = new Date();
    
    // Start of current month
    const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
    periodStart.setHours(0, 0, 0, 0);

    // End of current month
    const periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    periodEnd.setHours(23, 59, 59, 999);

    const periodId = crypto.randomUUID();

    await this.env.DB
      .prepare(`
        INSERT INTO billing_periods
        (id, workspace_id, period_start, period_end, subtotal, 
         subscription_fee, total_amount, status, created_at)
        VALUES (?, ?, ?, ?, 0, 0, 0, 'current', ?)
      `)
      .bind(
        periodId,
        workspaceId,
        periodStart.getTime(),
        periodEnd.getTime(),
        Date.now()
      )
      .run();

    return periodId;
  }

  private async updateBillingPeriodTotals(periodId: string): Promise<void> {
    // Calculate totals from usage records
    const totals = await this.env.DB
      .prepare(`
        SELECT SUM(final_cost) as subtotal
        FROM usage_records
        WHERE billing_period_id = ?
      `)
      .bind(periodId)
      .first();

    const subtotal = totals?.subtotal || 0;

    // Get subscription fee
    const period = await this.env.DB
      .prepare(`
        SELECT workspace_id, subscription_fee
        FROM billing_periods
        WHERE id = ?
      `)
      .bind(periodId)
      .first();

    const subscriptionFee = period?.subscription_fee || 0;
    const totalAmount = subtotal + subscriptionFee;

    // Update period
    await this.env.DB
      .prepare(`
        UPDATE billing_periods
        SET subtotal = ?, total_amount = ?
        WHERE id = ?
      `)
      .bind(subtotal, totalAmount, periodId)
      .run();
  }

  private async checkUsageLimits(workspaceId: string): Promise<void> {
    // Get workspace settings
    const settings = await this.env.DB
      .prepare(`
        SELECT usage_limit_monthly, alert_threshold_percentage, auto_pause_on_limit
        FROM workspace_billing_settings
        WHERE workspace_id = ?
      `)
      .bind(workspaceId)
      .first();

    if (!settings || !settings.usage_limit_monthly) {
      return; // No limits configured
    }

    // Get current period usage
    const period = await this.env.DB
      .prepare(`
        SELECT total_amount
        FROM billing_periods
        WHERE workspace_id = ? AND status = 'current'
      `)
      .bind(workspaceId)
      .first();

    if (!period) return;

    const usagePercentage = (period.total_amount / settings.usage_limit_monthly) * 100;

    // Check if threshold exceeded
    if (usagePercentage >= settings.alert_threshold_percentage) {
      await this.sendUsageAlert(workspaceId, usagePercentage);
    }

    // Check if limit exceeded
    if (usagePercentage >= 100 && settings.auto_pause_on_limit) {
      await this.pauseWorkspaceAgents(workspaceId);
    }
  }

  private async sendUsageAlert(
    workspaceId: string,
    usagePercentage: number
  ): Promise<void> {
    
    // Get workspace owner email
    const workspace = await this.env.DB
      .prepare(`
        SELECT w.name, u.email
        FROM workspaces w
        JOIN workspace_members wm ON w.id = wm.workspace_id
        JOIN client_users u ON wm.user_id = u.id
        WHERE w.id = ? AND wm.role = 'owner'
      `)
      .bind(workspaceId)
      .first();

    if (!workspace) return;

    // Send email alert (implement email service)
    console.log(`Usage alert: ${workspace.name} at ${usagePercentage.toFixed(1)}%`);
    
    // In production, integrate with email service (SendGrid, AWS SES, etc.)
  }

  private async pauseWorkspaceAgents(workspaceId: string): Promise<void> {
    // Pause all active agents
    await this.env.DB
      .prepare(`
        UPDATE voice_agents
        SET status = 'paused'
        WHERE workspace_id = ? AND status = 'live'
      `)
      .bind(workspaceId)
      .run();

    console.log(`Paused agents for workspace ${workspaceId} due to usage limit`);
  }

  async getUsageSummary(
    workspaceId: string,
    periodId?: string
  ): Promise<{
    subtotal: number;
    subscriptionFee: number;
    totalAmount: number;
    byResourceType: Array<{ type: string; quantity: number; cost: number }>;
    byProvider: Array<{ provider: string; cost: number }>;
  }> {
    
    // Get billing period
    let period;
    
    if (periodId) {
      period = await this.env.DB
        .prepare(`SELECT * FROM billing_periods WHERE id = ?`)
        .bind(periodId)
        .first();
    } else {
      period = await this.env.DB
        .prepare(`
          SELECT * FROM billing_periods
          WHERE workspace_id = ? AND status = 'current'
        `)
        .bind(workspaceId)
        .first();
    }

    if (!period) {
      return {
        subtotal: 0,
        subscriptionFee: 0,
        totalAmount: 0,
        byResourceType: [],
        byProvider: []
      };
    }

    // Get breakdown by resource type
    const byResourceType = await this.env.DB
      .prepare(`
        SELECT 
          resource_type as type,
          SUM(quantity) as quantity,
          SUM(final_cost) as cost
        FROM usage_records
        WHERE billing_period_id = ?
        GROUP BY resource_type
      `)
      .bind(period.id)
      .all();

    // Get breakdown by provider
    const byProvider = await this.env.DB
      .prepare(`
        SELECT 
          provider,
          SUM(final_cost) as cost
        FROM usage_records
        WHERE billing_period_id = ?
        GROUP BY provider
      `)
      .bind(period.id)
      .all();

    return {
      subtotal: period.subtotal || 0,
      subscriptionFee: period.subscription_fee || 0,
      totalAmount: period.total_amount || 0,
      byResourceType: byResourceType.results.map(r => ({
        type: r.type,
        quantity: r.quantity,
        cost: r.cost
      })),
      byProvider: byProvider.results.map(r => ({
        provider: r.provider,
        cost: r.cost
      }))
    };
  }
}
```

---

## 7.4 Billing Engine

```typescript
// ============================================
// BILLING ENGINE
// Handles billing period finalization and invoicing
// ============================================

class BillingEngine {
  constructor(private env: Env) {}

  async finalizeBillingPeriod(periodId: string): Promise<void> {
    // Get billing period
    const period = await this.env.DB
      .prepare(`SELECT * FROM billing_periods WHERE id = ?`)
      .bind(periodId)
      .first();

    if (!period) {
      throw new Error('Billing period not found');
    }

    if (period.status !== 'current') {
      throw new Error('Can only finalize current billing periods');
    }

    // Calculate final totals
    const totals = await this.env.DB
      .prepare(`
        SELECT SUM(final_cost) as subtotal
        FROM usage_records
        WHERE billing_period_id = ?
      `)
      .bind(periodId)
      .first();

    const subtotal = totals?.subtotal || 0;

    // Get subscription fee for this workspace
    const subscriptionFee = await this.getSubscriptionFee(period.workspace_id);
    const totalAmount = subtotal + subscriptionFee;

    // Update billing period
    await this.env.DB
      .prepare(`
        UPDATE billing_periods
        SET subtotal = ?, subscription_fee = ?, total_amount = ?, status = 'finalized'
        WHERE id = ?
      `)
      .bind(subtotal, subscriptionFee, totalAmount, periodId)
      .run();

    // Create Stripe invoice
    if (totalAmount > 0) {
      await this.createStripeInvoice(periodId);
    }

    // Create new current period for next month
    await this.createNextBillingPeriod(period.workspace_id);
  }

  private async getSubscriptionFee(workspaceId: string): Promise<number> {
    const workspace = await this.env.DB
      .prepare(`
        SELECT subscription_tier
        FROM workspaces
        WHERE id = ?
      `)
      .bind(workspaceId)
      .first();

    if (!workspace) return 0;

    const tier = await this.env.DB
      .prepare(`
        SELECT monthly_fee
        FROM subscription_tiers
        WHERE tier_name = ?
      `)
      .bind(workspace.subscription_tier)
      .first();

    return tier?.monthly_fee || 0;
  }

  private async createStripeInvoice(periodId: string): Promise<void> {
    const period = await this.env.DB
      .prepare(`SELECT * FROM billing_periods WHERE id = ?`)
      .bind(periodId)
      .first();

    if (!period) return;

    // Get workspace and owner info
    const workspace = await this.env.DB
      .prepare(`
        SELECT w.*, u.email
        FROM workspaces w
        JOIN workspace_members wm ON w.id = wm.workspace_id
        JOIN client_users u ON wm.user_id = u.id
        WHERE w.id = ? AND wm.role = 'owner'
      `)
      .bind(period.workspace_id)
      .first();

    if (!workspace) return;

    // Get or create Stripe customer
    const stripeCustomerId = await this.getOrCreateStripeCustomer(
      workspace.email,
      workspace.name
    );

    // Get invoice items
    const items = await this.getInvoiceItems(periodId);

    // Create Stripe invoice
    const invoice = await this.createStripeInvoiceAPI(
      stripeCustomerId,
      items,
      period.total_amount
    );

    // Update billing period with Stripe invoice ID
    await this.env.DB
      .prepare(`
        UPDATE billing_periods
        SET stripe_invoice_id = ?
        WHERE id = ?
      `)
      .bind(invoice.id, periodId)
      .run();
  }

  private async getOrCreateStripeCustomer(
    email: string,
    name: string
  ): Promise<string> {
    
    // Check if customer exists in our database
    // For simplicity, creating new customer each time
    // In production, cache customer IDs

    const response = await fetch('https://api.stripe.com/v1/customers', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        email,
        name,
        description: `Vocalized customer: ${name}`
      })
    });

    if (!response.ok) {
      throw new Error('Failed to create Stripe customer');
    }

    const customer = await response.json();
    return customer.id;
  }

  private async getInvoiceItems(periodId: string): Promise<InvoiceItem[]> {
    // Get usage breakdown
    const usage = await this.env.DB
      .prepare(`
        SELECT 
          resource_type,
          SUM(quantity) as total_quantity,
          SUM(final_cost) as total_cost
        FROM usage_records
        WHERE billing_period_id = ?
        GROUP BY resource_type
      `)
      .bind(periodId)
      .all();

    // Get subscription fee
    const period = await this.env.DB
      .prepare(`SELECT subscription_fee FROM billing_periods WHERE id = ?`)
      .bind(periodId)
      .first();

    const items: InvoiceItem[] = [];

    // Add subscription fee if applicable
    if (period?.subscription_fee > 0) {
      items.push({
        description: 'Monthly Subscription',
        quantity: 1,
        unitPrice: period.subscription_fee,
        amount: period.subscription_fee
      });
    }

    // Add usage items
    for (const row of usage.results) {
      const description = this.formatResourceType(row.resource_type);
      items.push({
        description,
        quantity: row.total_quantity,
        unitPrice: row.total_cost / row.total_quantity,
        amount: row.total_cost
      });
    }

    return items;
  }

  private formatResourceType(type: string): string {
    const formats: Record<string, string> = {
      call_minutes: 'Call Minutes',
      transcription: 'Transcription',
      synthesis: 'Voice Synthesis',
      storage: 'Recording Storage'
    };

    return formats[type] || type;
  }

  private async createStripeInvoiceAPI(
    customerId: string,
    items: InvoiceItem[],
    totalAmount: number
  ): Promise<any> {
    
    // Create invoice items
    for (const item of items) {
      await fetch('https://api.stripe.com/v1/invoiceitems', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: new URLSearchParams({
          customer: customerId,
          description: item.description,
          quantity: item.quantity.toString(),
          unit_amount: Math.round(item.unitPrice * 100).toString(), // Cents
          currency: 'usd'
        })
      });
    }

    // Create invoice
    const response = await fetch('https://api.stripe.com/v1/invoices', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        customer: customerId,
        auto_advance: 'true',
        collection_method: 'charge_automatically'
      })
    });

    if (!response.ok) {
      throw new Error('Failed to create Stripe invoice');
    }

    const invoice = await response.json();

    // Finalize invoice
    await fetch(`https://api.stripe.com/v1/invoices/${invoice.id}/finalize`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.env.STRIPE_SECRET_KEY}`
      }
    });

    return invoice;
  }

  private async createNextBillingPeriod(workspaceId: string): Promise<void> {
    const now = new Date();
    now.setMonth(now.getMonth() + 1);

    const periodStart = new Date(now.getFullYear(), now.getMonth(), 1);
    periodStart.setHours(0, 0, 0, 0);

    const periodEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    periodEnd.setHours(23, 59, 59, 999);

    const periodId = crypto.randomUUID();

    await this.env.DB
      .prepare(`
        INSERT INTO billing_periods
        (id, workspace_id, period_start, period_end, subtotal, 
         subscription_fee, total_amount, status, created_at)
        VALUES (?, ?, ?, ?, 0, 0, 0, 'current', ?)
      `)
      .bind(
        periodId,
        workspaceId,
        periodStart.getTime(),
        periodEnd.getTime(),
        Date.now()
      )
      .run();
  }

  async handleStripeWebhook(request: Request): Promise<Response> {
    const signature = request.headers.get('stripe-signature');
    const body = await request.text();

    // Verify webhook signature
    // In production, use Stripe's webhook verification
    
    const event = JSON.parse(body);

    switch (event.type) {
      case 'invoice.paid':
        await this.handleInvoicePaid(event.data.object);
        break;
      
      case 'invoice.payment_failed':
        await this.handleInvoicePaymentFailed(event.data.object);
        break;
      
      case 'customer.subscription.deleted':
        await this.handleSubscriptionCancelled(event.data.object);
        break;
    }

    return Response.json({ received: true });
  }

  private async handleInvoicePaid(invoice: any): Promise<void> {
    // Find billing period by Stripe invoice ID
    const period = await this.env.DB
      .prepare(`
        SELECT id, workspace_id
        FROM billing_periods
        WHERE stripe_invoice_id = ?
      `)
      .bind(invoice.id)
      .first();

    if (!period) return;

    // Update billing period status
    await this.env.DB
      .prepare(`
        UPDATE billing_periods
        SET status = 'paid', paid_at = ?
        WHERE id = ?
      `)
      .bind(Date.now(), period.id)
      .run();

    console.log(`Invoice paid for workspace ${period.workspace_id}`);
  }

  private async handleInvoicePaymentFailed(invoice: any): Promise<void> {
    const period = await this.env.DB
      .prepare(`
        SELECT id, workspace_id
        FROM billing_periods
        WHERE stripe_invoice_id = ?
      `)
      .bind(invoice.id)
      .first();

    if (!period) return;

    // Update status to overdue
    await this.env.DB
      .prepare(`
        UPDATE billing_periods
        SET status = 'overdue'
        WHERE id = ?
      `)
      .bind(period.id)
      .run();

    // Suspend workspace
    await this.env.DB
      .prepare(`
        UPDATE workspaces
        SET status = 'suspended'
        WHERE id = ?
      `)
      .bind(period.workspace_id)
      .run();

    console.log(`Payment failed for workspace ${period.workspace_id}`);
  }

  private async handleSubscriptionCancelled(subscription: any): Promise<void> {
    // Handle subscription cancellation
    console.log('Subscription cancelled:', subscription.id);
  }
}
```

---

**Continue with Part 2 of Billing & Analytics (Analytics Engine, Reporting)?**
#vocalized